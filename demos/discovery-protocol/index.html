<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SYNTH TREE PROTOCOL - Self-Organizing Network Simulation</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        /* Global Styles - 80's Hackerpunk Theme */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Share Tech Mono', monospace;
            background-color: #000;
            background-image: 
                repeating-linear-gradient(
                    0deg,
                    rgba(0, 255, 0, 0.03) 0px,
                    transparent 1px,
                    transparent 2px,
                    rgba(0, 255, 0, 0.03) 3px
                );
            color: #00ff00;
            line-height: 1.6;
            min-height: 100vh;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
            animation: textFlicker 0.01s infinite;
        }

        @keyframes textFlicker {
            0% { opacity: 1; }
            50% { opacity: 0.99; }
            100% { opacity: 1; }
        }

        /* CRT screen effect */
        body::before {
            content: " ";
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            animation: scanline 8s linear infinite;
        }

        @keyframes scanline {
            0% { transform: translateY(0); }
            100% { transform: translateY(100vh); }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 3;
        }

        /* Header */
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px 0 20px;
            border: 2px solid #00ff00;
            border-left: none;
            border-right: none;
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 0, 0.4), transparent);
            animation: headerScan 3s linear infinite;
        }

        @keyframes headerScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .ascii-art {
            color: #00ff00;
            font-size: 0.6rem;
            line-height: 1;
            margin-bottom: 15px;
            text-align: center;
            font-family: 'Courier New', monospace;
            animation: asciiGlow 3s ease-in-out infinite;
        }

        @keyframes asciiGlow {
            0%, 100% { 
                text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
            }
            50% { 
                text-shadow: 0 0 20px rgba(0, 255, 0, 1), 0 0 30px rgba(0, 255, 0, 0.6);
            }
        }

        h1 {
            font-family: 'Orbitron', monospace;
            font-size: 3rem;
            font-weight: 900;
            letter-spacing: 0.2em;
            color: #00ff00;
            text-transform: uppercase;
            margin-bottom: 10px;
            animation: glitch 2s infinite;
            position: relative;
        }

        h1::before,
        h1::after {
            content: 'SYNTH TREE';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        h1::before {
            animation: glitch-1 0.5s infinite;
            color: #ff00ff;
            z-index: -1;
        }

        h1::after {
            animation: glitch-2 0.5s infinite;
            color: #00ffff;
            z-index: -2;
        }

        @keyframes glitch {
            0%, 100% { text-shadow: 0 0 10px rgba(0, 255, 0, 0.8); }
            20% { text-shadow: 3px 0 10px rgba(255, 0, 255, 0.8); }
            40% { text-shadow: -3px 0 10px rgba(0, 255, 255, 0.8); }
            60% { text-shadow: 0 0 10px rgba(0, 255, 0, 0.8); }
        }

        @keyframes glitch-1 {
            0%, 100% { clip-path: inset(0 0 0 0); transform: translate(0); }
            20% { clip-path: inset(20% 0 60% 0); transform: translate(-2px); }
            40% { clip-path: inset(50% 0 20% 0); transform: translate(2px); }
            60% { clip-path: inset(10% 0 80% 0); transform: translate(0); }
            80% { clip-path: inset(80% 0 10% 0); transform: translate(1px); }
        }

        @keyframes glitch-2 {
            0%, 100% { clip-path: inset(0 0 0 0); transform: translate(0); }
            20% { clip-path: inset(60% 0 20% 0); transform: translate(2px); }
            40% { clip-path: inset(20% 0 50% 0); transform: translate(-2px); }
            60% { clip-path: inset(80% 0 10% 0); transform: translate(1px); }
            80% { clip-path: inset(10% 0 80% 0); transform: translate(-1px); }
        }

        .tagline {
            font-size: 1rem;
            color: #ff00ff;
            text-transform: uppercase;
            letter-spacing: 0.3em;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        /* Main Layout */
        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Control Panels */
        .control-panel {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff00ff;
            padding: 20px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.3);
        }

        .control-panel::before {
            content: 'SYSTEM://';
            position: absolute;
            top: -2px;
            left: -2px;
            background: #ff00ff;
            color: #000;
            padding: 2px 10px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .control-panel h3 {
            color: #ff00ff;
            margin-bottom: 15px;
            margin-top: 10px;
            font-size: 1.2em;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .stats-panel {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            padding: 20px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .stats-panel::before {
            content: 'TELEMETRY://';
            position: absolute;
            top: -2px;
            left: -2px;
            background: #00ffff;
            color: #000;
            padding: 2px 10px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .stats-panel h3 {
            color: #00ffff;
            margin-bottom: 15px;
            margin-top: 10px;
            font-size: 1.2em;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 12px 20px;
            margin-bottom: 10px;
            border: 2px solid #00ff00;
            background: #000;
            color: #00ff00;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-family: 'Share Tech Mono', monospace;
            position: relative;
            overflow: hidden;
        }
        
        .btn-small {
            width: 48%;
            padding: 8px 12px;
            font-size: 0.85rem;
            display: inline-block;
        }
        
        .control-row {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .view-controls {
            margin-bottom: 15px;
        }
        
        .view-controls select {
            width: 100%;
            padding: 8px 12px;
            background: #000;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.9rem;
            text-transform: uppercase;
            cursor: pointer;
            margin-bottom: 10px;
        }
        
        .view-controls select:focus {
            outline: none;
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .view-controls option {
            background: #000;
            color: #00ff00;
        }
        
        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .zoom-label {
            color: #00ffff;
            font-size: 0.8rem;
            text-transform: uppercase;
            flex: 1;
        }
        
        .zoom-value {
            color: #ffff00;
            font-family: 'Orbitron', monospace;
            font-weight: bold;
            min-width: 50px;
            text-align: center;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(0, 255, 0, 0.3);
            transition: left 0.3s ease;
        }

        .btn:hover {
            color: #000;
            background: #00ff00;
            box-shadow: 0 0 20px #00ff00;
            text-shadow: none;
        }

        .btn:hover::before {
            left: 0;
        }

        .btn-danger {
            border-color: #ff0000;
            color: #ff0000;
        }

        .btn-danger:hover {
            background: #ff0000;
            box-shadow: 0 0 20px #ff0000;
        }

        /* Stat Items */
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            position: relative;
        }

        .stat-item::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, #00ffff, transparent);
            animation: statScan 3s linear infinite;
        }

        @keyframes statScan {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .stat-label {
            color: #ff00ff;
            font-size: 0.85rem;
            text-transform: uppercase;
        }

        .stat-value {
            color: #00ff00;
            font-weight: bold;
            font-family: 'Orbitron', monospace;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
        }

        /* Visualization Panel */
        .visualization-panel {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff00;
            padding: 20px;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 0 20px rgba(0, 255, 0, 0.5),
                inset 0 0 20px rgba(0, 255, 0, 0.1);
        }

        .visualization-panel::before {
            content: 'SYNTH_TREE://TOPOLOGY_MAP';
            position: absolute;
            top: -2px;
            left: -2px;
            background: #00ff00;
            color: #000;
            padding: 2px 10px;
            font-size: 0.8rem;
            font-weight: bold;
            z-index: 1;
        }

        .network-container {
            width: 100%;
            height: 600px;
            background: #000;
            position: relative;
            overflow: hidden;
            cursor: grab;
            border: 1px solid rgba(0, 255, 0, 0.3);
        }

        .network-container.dragging {
            cursor: grabbing;
        }
        
        .node-draggable {
            cursor: grab;
        }
        
        .node-draggable:hover {
            cursor: grab;
        }

        /* Node Styles */
        .node {
            position: absolute;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ffff00;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid #fff;
            font-family: 'Orbitron', monospace;
            text-shadow: 
                0 0 8px #ffff00,
                0 0 12px #ffff00,
                2px 2px 0px #000,
                -2px -2px 0px #000,
                2px -2px 0px #000,
                -2px 2px 0px #000;
        }

        .node:hover {
            transform: scale(1.3);
            z-index: 10;
        }

        .node-mainframe {
            background: #ff0000;
            width: 32px;
            height: 32px;
            box-shadow: 0 0 15px #ff0000;
            animation: mainframePulse 2s ease-in-out infinite;
        }

        @keyframes mainframePulse {
            0%, 100% { box-shadow: 0 0 15px #ff0000; }
            50% { box-shadow: 0 0 25px #ff0000, 0 0 35px rgba(255, 0, 0, 0.5); }
        }

        .node-relay {
            background: #ff8800;
            width: 28px;
            height: 28px;
            box-shadow: 0 0 12px #ff8800;
        }

        .node-node {
            background: #00ff00;
            width: 24px;
            height: 24px;
            box-shadow: 0 0 10px #00ff00;
            color: #000;
            text-shadow: 
                0 0 8px #000,
                0 0 12px #000,
                2px 2px 0px #00ff00,
                -2px -2px 0px #00ff00,
                2px -2px 0px #00ff00,
                -2px 2px 0px #00ff00;
        }

        .node-terminal {
            background: #00ffff;
            width: 20px;
            height: 20px;
            box-shadow: 0 0 8px #00ffff;
            color: #000;
            text-shadow: 
                0 0 8px #000,
                0 0 12px #000,
                2px 2px 0px #00ffff,
                -2px -2px 0px #00ffff,
                2px -2px 0px #00ffff,
                -2px 2px 0px #00ffff;
        }

        .node-discovering {
            background: #ff00ff;
            width: 22px;
            height: 22px;
            animation: discoveringPulse 1s infinite;
            box-shadow: 0 0 15px #ff00ff;
        }

        @keyframes discoveringPulse {
            0% { opacity: 0.6; transform: scale(1); box-shadow: 0 0 10px #ff00ff; }
            50% { opacity: 1; transform: scale(1.2); box-shadow: 0 0 20px #ff00ff, 0 0 30px rgba(255, 0, 255, 0.5); }
            100% { opacity: 0.6; transform: scale(1); box-shadow: 0 0 10px #ff00ff; }
        }

        /* Connection Lines */
        .connection {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, #00ff00, #00ffff);
            opacity: 0.6;
            pointer-events: none;
            transform-origin: left center;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }

        /* Discovery Messages */
        .discovery-message {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            pointer-events: none;
            animation: messagePulse 0.8s infinite;
            z-index: 5;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        @keyframes messagePulse {
            0% { opacity: 0.9; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.8); }
            100% { opacity: 0.9; transform: scale(1); }
        }

        .discovery-message.topology-request {
            background: #bb86fc;
            box-shadow: 
                0 0 15px #bb86fc,
                0 0 25px rgba(187, 134, 252, 0.6),
                inset 0 0 5px rgba(255, 255, 255, 0.3);
        }

        .discovery-message.topology-response {
            background: #cf6fff;
            box-shadow: 
                0 0 15px #cf6fff,
                0 0 25px rgba(207, 111, 255, 0.6),
                inset 0 0 5px rgba(255, 255, 255, 0.3);
        }

        .discovery-message.attach {
            background: #4ade80;
            box-shadow: 
                0 0 15px #4ade80,
                0 0 25px rgba(74, 222, 128, 0.6),
                inset 0 0 5px rgba(255, 255, 255, 0.3);
        }

        .discovery-message.confirm {
            background: #fb923c;
            box-shadow: 
                0 0 15px #fb923c,
                0 0 25px rgba(251, 146, 60, 0.6),
                inset 0 0 5px rgba(255, 255, 255, 0.3);
        }

        .discovery-message.migrate {
            background: #fbbf24;
            box-shadow: 
                0 0 15px #fbbf24,
                0 0 25px rgba(251, 191, 36, 0.6),
                inset 0 0 5px rgba(255, 255, 255, 0.3);
        }

        .discovery-message.discovery {
            background: #06d6a0;
            box-shadow: 
                0 0 15px #06d6a0,
                0 0 25px rgba(6, 214, 160, 0.6),
                inset 0 0 5px rgba(255, 255, 255, 0.3);
        }

        .discovery-message.health {
            background: #22c55e;
            box-shadow: 
                0 0 12px #22c55e,
                0 0 20px rgba(34, 197, 94, 0.4),
                inset 0 0 5px rgba(255, 255, 255, 0.2);
        }

        .discovery-message.health-response {
            background: #16a34a;
            box-shadow: 
                0 0 12px #16a34a,
                0 0 20px rgba(22, 163, 74, 0.4),
                inset 0 0 5px rgba(255, 255, 255, 0.2);
        }

        .discovery-message.status-broadcast {
            background: #eab308;
            box-shadow: 
                0 0 12px #eab308,
                0 0 20px rgba(234, 179, 8, 0.5),
                inset 0 0 5px rgba(255, 255, 255, 0.3);
        }

        .discovery-message.peer-keepalive {
            background: #8b5cf6;
            box-shadow: 
                0 0 12px #8b5cf6,
                0 0 20px rgba(139, 92, 246, 0.4),
                inset 0 0 5px rgba(255, 255, 255, 0.2);
        }

        .discovery-message.capacity-check {
            background: #f59e0b;
            box-shadow: 
                0 0 12px #f59e0b,
                0 0 20px rgba(245, 158, 11, 0.4),
                inset 0 0 5px rgba(255, 255, 255, 0.2);
        }

        /* Event Log */
        .event-log {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ffff00;
            padding: 20px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.3);
        }

        .event-log::before {
            content: 'CONSOLE://EVENT_STREAM';
            position: absolute;
            top: -2px;
            left: -2px;
            background: #ffff00;
            color: #000;
            padding: 2px 10px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .event-log h3 {
            color: #ffff00;
            margin-bottom: 15px;
            margin-top: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .log-content {
            height: 150px;
            overflow-y: auto;
            padding: 10px;
            background: #000;
            border: 1px solid rgba(255, 255, 0, 0.3);
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.85rem;
        }

        .log-content::-webkit-scrollbar {
            width: 8px;
        }

        .log-content::-webkit-scrollbar-track {
            background: #000;
            border: 1px solid #ffff00;
        }

        .log-content::-webkit-scrollbar-thumb {
            background: #ffff00;
            border: 1px solid #000;
        }

        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 0, 0.2);
            animation: logSlide 0.5s ease;
        }

        @keyframes logSlide {
            from { 
                opacity: 0; 
                transform: translateX(-20px);
            }
            to { 
                opacity: 1; 
                transform: translateX(0);
            }
        }

        .log-time {
            color: #666;
            margin-right: 8px;
            font-size: 0.75rem;
        }

        .log-message {
            color: #ffff00;
        }

        .log-message.success {
            color: #00ff00;
        }

        .log-message.warning {
            color: #ff8800;
        }

        .log-message.error {
            color: #ff0000;
            animation: errorBlink 1s ease-in-out infinite;
        }

        @keyframes errorBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .log-message.info {
            color: #00ffff;
        }

        /* Protocol Info */
        .protocol-info {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            padding: 15px;
            position: relative;
            overflow: hidden;
        }

        .protocol-info::before {
            content: 'PROTOCOL://INFO';
            position: absolute;
            top: -2px;
            left: -2px;
            background: #00ffff;
            color: #000;
            padding: 2px 10px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .protocol-info h4 {
            color: #00ffff;
            margin-bottom: 10px;
            margin-top: 5px;
            font-size: 0.9rem;
            text-transform: uppercase;
        }

        .protocol-info ul {
            list-style: none;
            padding-left: 0;
        }

        .protocol-info li {
            padding: 4px 0;
            padding-left: 15px;
            position: relative;
            color: #00ff00;
            font-size: 0.8rem;
        }

        .protocol-info li:before {
            content: "▶";
            position: absolute;
            left: 0;
            color: #ff00ff;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Developer Documentation */
        .developer-docs {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            padding: 25px;
            margin: 30px 0 20px 0;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        
        .developer-docs::before {
            content: 'DEVELOPER://DOCUMENTATION';
            position: absolute;
            top: -2px;
            left: -2px;
            background: #00ffff;
            color: #000;
            padding: 2px 10px;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .developer-docs h3 {
            color: #00ffff;
            margin-bottom: 20px;
            margin-top: 10px;
            font-size: 1.3rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            text-align: center;
        }
        
        .doc-section {
            margin-bottom: 25px;
            padding: 15px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            background: rgba(0, 255, 255, 0.05);
        }
        
        .doc-section h4 {
            color: #ffff00;
            margin-bottom: 12px;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .doc-section p {
            color: #00ff00;
            line-height: 1.6;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }
        
        .doc-section em {
            color: #ff00ff;
            font-style: italic;
        }
        
        .doc-section strong {
            color: #ffff00;
            font-weight: bold;
        }
        
        .doc-section ul, .doc-section ol {
            margin-left: 20px;
            color: #00ff00;
        }
        
        .doc-section li {
            margin-bottom: 5px;
            line-height: 1.5;
        }
        
        .traffic-legend {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        
        .traffic-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
            animation: dotPulse 2s infinite;
        }
        
        @keyframes dotPulse {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }
        
        .traffic-purple { background: #bb86fc; box-shadow: 0 0 8px #bb86fc; }
        .traffic-pink { background: #cf6fff; box-shadow: 0 0 8px #cf6fff; }
        .traffic-green { background: #22c55e; box-shadow: 0 0 8px #22c55e; }
        .traffic-yellow { background: #eab308; box-shadow: 0 0 8px #eab308; }
        .traffic-orange { background: #fb923c; box-shadow: 0 0 8px #fb923c; }
        .traffic-cyan { background: #06d6a0; box-shadow: 0 0 8px #06d6a0; }
        
        /* Footer */
        .footer-version {
            font-size: 0.7rem;
            color: #333;
            text-align: center;
            margin: 20px 0 10px 0;
            opacity: 0.6;
            font-family: 'Share Tech Mono', monospace;
            text-shadow: none;
            letter-spacing: 1px;
            border-top: 1px solid #222;
            padding-top: 15px;
        }

        /* Mobile Responsive */
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 300px 1fr;
            }
        }

        @media (max-width: 992px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .left-panel {
                order: 2;
            }
            
            .visualization-panel {
                order: 1;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .network-container {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <pre class="ascii-art">
╔═══════════════════════════════════════════════════════════════╗
║                                                               ║
║      ███████╗██╗   ██╗███╗   ██╗████████╗██╗  ██╗             ║
║      ██╔════╝╚██╗ ██╔╝████╗  ██║╚══██╔══╝██║  ██║             ║
║      ███████╗ ╚████╔╝ ██╔██╗ ██║   ██║   ███████║             ║
║      ╚════██║  ╚██╔╝  ██║╚██╗██║   ██║   ██╔══██║             ║
║      ███████║   ██║   ██║ ╚████║   ██║   ██║  ██║             ║
║      ╚══════╝   ╚═╝   ╚═╝  ╚═══╝   ╚═╝   ╚═╝  ╚═╝             ║
║                                                               ║
║           ████████╗██████╗ ███████╗███████╗                  ║
║           ╚══██╔══╝██╔══██╗██╔════╝██╔════╝                  ║
║              ██║   ██████╔╝█████╗  █████╗                    ║
║              ██║   ██╔══██╗██╔══╝  ██╔══╝                    ║
║              ██║   ██║  ██║███████╗███████╗                  ║
║              ╚═╝   ╚═╝  ╚═╝╚══════╝╚══════╝                  ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
            </pre>
            <h1>SYNTH TREE</h1>
            <p class="tagline">[ SELF-ORGANIZING NETWORK PROTOCOL // SYNTHETIC TREE ]</p>
        </header>

        <div class="main-content">
            <div class="left-panel">
                <div class="control-panel">
                    <h3>NETWORK CONTROL</h3>
                    <div class="view-controls">
                        <select id="viewSelect">
                            <option value="free">Free Form View</option>
                            <option value="radial">Radial View</option>
                            <option value="tree">Tree View</option>
                        </select>
                        <div class="zoom-controls">
                            <span class="zoom-label">Zoom:</span>
                            <button id="zoomOutBtn" class="btn btn-small">-</button>
                            <span id="zoomValue" class="zoom-value">100%</span>
                            <button id="zoomInBtn" class="btn btn-small">+</button>
                        </div>
                    </div>
                    <button id="addNodeBtn" class="btn">ADD NODE</button>
                    <button id="addMultipleBtn" class="btn">ADD 5 NODES</button>
                    <button id="stepBtn" class="btn">RUN DISCOVERY ROUND</button>
                    <button id="autoRunBtn" class="btn">AUTO RUN</button>
                    <button id="resetBtn" class="btn btn-danger">RESET NETWORK</button>
                </div>

                <div class="stats-panel">
                    <h3>NETWORK TELEMETRY</h3>
                    <div class="stat-item">
                        <span class="stat-label">Total Nodes:</span>
                        <span id="totalNodes" class="stat-value">3</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Mainframes:</span>
                        <span id="mainframeNodes" class="stat-value">3</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Relays:</span>
                        <span id="relayNodes" class="stat-value">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Nodes:</span>
                        <span id="nodeNodes" class="stat-value">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Terminals:</span>
                        <span id="terminalNodes" class="stat-value">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Average Depth:</span>
                        <span id="avgDepth" class="stat-value">0.00</span>
                    </div>
                </div>

                <div class="protocol-info">
                    <h4>PROTOCOL FEATURES</h4>
                    <ul>
                        <li>Self-organizing matrix structure</li>
                        <li>Latency-based node attachment</li>
                        <li>Real-time network optimization</li>
                        <li>Automatic failure recovery</li>
                        <li>Geographic clustering emergence</li>
                        <li>Capacity-driven promotion</li>
                    </ul>
                </div>
            </div>

            <div class="visualization-panel">
                <div id="networkContainer" class="network-container"></div>
            </div>
        </div>

        <div class="event-log">
            <h3>EVENT STREAM</h3>
            <div id="eventLog" class="log-content"></div>
        </div>
        
        <!-- Developer Documentation -->
        <div class="developer-docs">
            <h3>PROTOCOL DOCUMENTATION</h3>
            
            <div class="doc-section">
                <h4>📖 WHAT YOU'RE SEEING</h4>
                <p>This is a <strong>live simulation</strong> of the SYNTH TREE discovery protocol - a self-organizing network system. The colored dots represent network nodes that automatically arrange themselves into an efficient hierarchy based on network latency and capacity limits. Watch as nodes join, discover each other, and form connections through animated packet exchanges. You can add new nodes, trigger discovery rounds, and observe how the network adapts to changes and failures in real-time.</p>
                <p><strong>Try it:</strong> Click "SPAWN NODE" to add a new node and watch it find its place in the network, or hit "RUN DISCOVERY ROUND" to see optimization traffic in action! You can also <strong>click any non-mainframe node to kill it</strong> and witness the network's self-healing as orphaned nodes automatically reconnect.</p>
            </div>
            
            <div class="doc-section">
                <h4>🏗️ TOPOLOGY vs DATA FLOW</h4>
                <p>The tree connections you see represent the <strong>discovery topology</strong>, not data transmission paths. Nodes use this hierarchy purely for service discovery - to learn who exists in the network. Once discovered, <strong>data flows directly</strong> between any two nodes via standard internet routing, regardless of tree position.</p>
                <p><em>Example:</em> A Terminal in Tokyo can send data directly to a Terminal in London, even though they're under different Relays. The tree just told them about each other's existence.</p>
            </div>
            
            <div class="doc-section">
                <h4>🎯 PROTOCOL PURPOSE</h4>
                <p>SYNTH TREE solves the <strong>peer discovery problem</strong> for distributed applications. Instead of hardcoding server lists or requiring external coordination, nodes automatically:</p>
                <ul>
                    <li>Find the optimal attachment point based on network latency</li>
                    <li>Learn about all other nodes in the network</li>
                    <li>Self-organize into efficient geographic clusters</li>
                    <li>Adapt when nodes join, leave, or fail</li>
                </ul>
            </div>
            
            <div class="doc-section">
                <h4>🔮 DISCOVERY ROUNDS</h4>
                <p>Discovery rounds are periodic optimization cycles where nodes probe the network for better positions. Each round involves:</p>
                <ol>
                    <li><span class="dot traffic-purple"></span> Purple packets - Topology requests to mainframes</li>
                    <li><span class="dot traffic-pink"></span> Pink packets - Network topology responses</li>
                    <li><span class="dot traffic-yellow"></span> Yellow packets - Migration requests to better parents</li>
                    <li><span class="dot traffic-orange"></span> Orange packets - Attachment confirmations</li>
                </ol>
                <p>This creates a self-optimizing network that continuously improves its structure.</p>
            </div>
            
            <div class="doc-section">
                <h4>📡 NETWORK TRAFFIC TYPES</h4>
                <div class="traffic-legend">
                    <div class="traffic-item"><span class="dot traffic-purple"></span> Topology Discovery</div>
                    <div class="traffic-item"><span class="dot traffic-pink"></span> Network Responses</div>
                    <div class="traffic-item"><span class="dot traffic-green"></span> Health Checks</div>
                    <div class="traffic-item"><span class="dot traffic-yellow"></span> Status Broadcasts</div>
                    <div class="traffic-item"><span class="dot traffic-orange"></span> Migration Traffic</div>
                    <div class="traffic-item"><span class="dot traffic-cyan"></span> Peer Keepalives</div>
                </div>
                <p>The animated data packets represent control plane traffic for network coordination, not user data transmission.</p>
            </div>
            
            <div class="doc-section">
                <h4>🌍 REAL-WORLD APPLICATION</h4>
                <p>In production, this protocol enables applications like REPRAM to deploy globally without complex configuration. Nodes automatically discover each other, form efficient clusters, and maintain network health - perfect for distributed databases, CDNs, or any system requiring dynamic peer discovery.</p>
            </div>
        </div>
        
        <div class="footer-version">SYNTH-TREE v0.1 "Cyberpunk-Matrix" // REPRAM.io</div>
    </div>

    <script>
        class DiscoverySimulation {
            constructor() {
                console.log('SYNTH TREE PROTOCOL MATRIX INITIALIZING...');
                
                this.nodes = new Map();
                this.nodeIdCounter = 1;
                this.autoRunInterval = null;
                this.discoveryMessages = [];
                
                // Realistic capacity limits based on protocol (hackerpunk rebranded)
                this.capacities = {
                    mainframe: 15,  // Mainframes can handle more direct connections (was root)
                    relay: 8,       // Relays: 5-15 per protocol (was trunk)
                    node: 15,       // Nodes: 10-25 per protocol (was branch)
                    terminal: 0     // Terminals cannot have children (was leaf)
                };
                
                // Protocol parameters
                this.migrationThreshold = 0.25; // 25% improvement needed
                this.migrationCooldown = 10000;  // 10 seconds between migrations
                this.discoveryTimeout = 8000;    // 8 seconds for discovery
                
                this.container = document.getElementById('networkContainer');
                this.viewOffset = { x: 0, y: 0 };
                this.isDragging = false;
                this.dragStart = { x: 0, y: 0 };
                this.zoom = 1.0;
                this.viewMode = 'free'; // free, radial, tree
                this.isDraggingNode = false;
                this.draggedNode = null;
                this.nodeDragStart = { x: 0, y: 0 };
                
                this.initializeMainframes();
                this.setupEventHandlers();
                this.startDiscoveryAnimation();
                this.updateVisualization();
                this.updateStats();
                
                // Center on mainframes for mobile
                if (this.isMobile()) {
                    setTimeout(() => this.centerOnMainframes(), 100);
                }
                
                console.log('SYNTH TREE MATRIX ONLINE - READY FOR NODE INJECTION');
                this.logEvent('SYNTH TREE MATRIX INITIALIZED - 3 MAINFRAME NODES ACTIVE', 'success');
            }
            
            initializeMainframes() {
                const mainframeLocations = [
                    { name: 'MAINFRAME-ALPHA', lat: 40.7128, lon: -74.0060, label: 'α' },
                    { name: 'MAINFRAME-BETA', lat: 51.5074, lon: -0.1278, label: 'β' },
                    { name: 'MAINFRAME-GAMMA', lat: 35.6762, lon: 139.6503, label: 'γ' }
                ];
                
                mainframeLocations.forEach((loc, index) => {
                    const node = {
                        id: loc.name,
                        type: 'mainframe',
                        location: { lat: loc.lat, lon: loc.lon },
                        label: loc.label,
                        parent: null,
                        children: [],
                        capacity: this.capacities.mainframe,
                        depth: 0,
                        isAlive: true,
                        x: 150 + index * 250,
                        y: 100
                    };
                    this.nodes.set(loc.name, node);
                });
            }
            
            setupEventHandlers() {
                document.getElementById('addNodeBtn').addEventListener('click', () => {
                    this.addNode();
                });
                
                document.getElementById('addMultipleBtn').addEventListener('click', () => {
                    this.addMultipleNodes(5);
                });
                
                document.getElementById('stepBtn').addEventListener('click', () => {
                    this.runDiscoveryRound();
                });
                
                document.getElementById('autoRunBtn').addEventListener('click', () => {
                    this.toggleAutoRun();
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.resetNetwork();
                });
                
                document.getElementById('viewSelect').addEventListener('change', (e) => {
                    this.setViewMode(e.target.value);
                });
                
                document.getElementById('zoomInBtn').addEventListener('click', () => {
                    this.adjustZoom(0.2);
                });
                
                document.getElementById('zoomOutBtn').addEventListener('click', () => {
                    this.adjustZoom(-0.2);
                });
                
                // Add drag functionality
                this.setupDragHandlers();
            }
            
            isMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                       (('ontouchstart' in window) && window.innerWidth <= 768);
            }
            
            centerOnMainframes() {
                const mainframes = Array.from(this.nodes.values()).filter(n => n.type === 'mainframe');
                if (mainframes.length === 0) return;
                
                // Calculate center of mainframes
                let centerX = mainframes.reduce((sum, n) => sum + n.x, 0) / mainframes.length;
                let centerY = mainframes.reduce((sum, n) => sum + n.y, 0) / mainframes.length;
                
                // Center viewport on mainframes
                const containerRect = this.container.getBoundingClientRect();
                this.viewOffset.x = (containerRect.width / 2) - (centerX * this.zoom);
                this.viewOffset.y = (containerRect.height / 2) - (centerY * this.zoom);
                
                this.updateVisualization();
            }
            
            setupDragHandlers() {
                const container = this.container;
                
                // Mouse events
                container.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('node')) {
                        // Node dragging in free-form mode only
                        if (this.viewMode === 'free') {
                            this.startNodeDrag(e);
                        }
                        e.stopPropagation();
                        return;
                    }
                    
                    // Pan dragging
                    this.isDragging = true;
                    this.dragStart = { x: e.clientX - this.viewOffset.x, y: e.clientY - this.viewOffset.y };
                    container.classList.add('dragging');
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isDraggingNode && this.draggedNode && this.viewMode === 'free') {
                        // Node dragging
                        const rect = container.getBoundingClientRect();
                        const mouseX = (e.clientX - rect.left - this.viewOffset.x) / this.zoom;
                        const mouseY = (e.clientY - rect.top - this.viewOffset.y) / this.zoom;
                        
                        this.draggedNode.x = mouseX;
                        this.draggedNode.y = mouseY;
                        
                        this.updateVisualization();
                        e.preventDefault();
                        return;
                    }
                    
                    if (!this.isDragging) return;
                    
                    // Pan dragging
                    this.viewOffset.x = e.clientX - this.dragStart.x;
                    this.viewOffset.y = e.clientY - this.dragStart.y;
                    
                    this.updateVisualization();
                    e.preventDefault();
                });
                
                document.addEventListener('mouseup', () => {
                    if (this.isDraggingNode) {
                        this.isDraggingNode = false;
                        this.draggedNode = null;
                        container.style.cursor = 'grab';
                    }
                    
                    if (this.isDragging) {
                        this.isDragging = false;
                        container.classList.remove('dragging');
                    }
                });
                
                // Add wheel zoom
                container.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? -0.1 : 0.1;
                    this.adjustZoom(delta);
                });
                
                // Touch events for mobile
                container.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        const touch = e.touches[0];
                        
                        // Check if touching a node
                        const element = document.elementFromPoint(touch.clientX, touch.clientY);
                        if (element && element.classList.contains('node')) {
                            if (this.viewMode === 'free') {
                                this.startNodeDragTouch(touch, element);
                            }
                            e.preventDefault();
                            return;
                        }
                        
                        // Pan dragging
                        this.isDragging = true;
                        this.dragStart = { x: touch.clientX - this.viewOffset.x, y: touch.clientY - this.viewOffset.y };
                        container.classList.add('dragging');
                        e.preventDefault();
                    }
                });
                
                container.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 1) {
                        const touch = e.touches[0];
                        
                        if (this.isDraggingNode && this.draggedNode && this.viewMode === 'free') {
                            // Node dragging
                            const rect = container.getBoundingClientRect();
                            const touchX = (touch.clientX - rect.left - this.viewOffset.x) / this.zoom;
                            const touchY = (touch.clientY - rect.top - this.viewOffset.y) / this.zoom;
                            
                            this.draggedNode.x = touchX;
                            this.draggedNode.y = touchY;
                            
                            this.updateVisualization();
                            e.preventDefault();
                            return;
                        }
                        
                        if (this.isDragging) {
                            // Pan dragging
                            this.viewOffset.x = touch.clientX - this.dragStart.x;
                            this.viewOffset.y = touch.clientY - this.dragStart.y;
                            
                            this.updateVisualization();
                            e.preventDefault();
                        }
                    }
                });
                
                container.addEventListener('touchend', (e) => {
                    if (this.isDraggingNode) {
                        this.isDraggingNode = false;
                        this.draggedNode = null;
                        container.style.cursor = 'grab';
                    }
                    
                    if (this.isDragging) {
                        this.isDragging = false;
                        container.classList.remove('dragging');
                    }
                    
                    e.preventDefault();
                });
            }
            
            startNodeDrag(e) {
                const nodeId = e.target.textContent;
                let targetNode = null;
                
                // Find the node by its label
                for (const [id, node] of this.nodes) {
                    if (node.label === nodeId || node.id.includes(nodeId)) {
                        targetNode = node;
                        break;
                    }
                }
                
                if (targetNode && targetNode.type !== 'mainframe') {
                    this.isDraggingNode = true;
                    this.draggedNode = targetNode;
                    this.container.style.cursor = 'grabbing';
                    
                    const rect = this.container.getBoundingClientRect();
                    this.nodeDragStart = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                }
            }
            
            startNodeDragTouch(touch, element) {
                const nodeId = element.textContent;
                let targetNode = null;
                
                // Find the node by its label
                for (const [id, node] of this.nodes) {
                    if (node.label === nodeId || node.id.includes(nodeId)) {
                        targetNode = node;
                        break;
                    }
                }
                
                if (targetNode && targetNode.type !== 'mainframe') {
                    this.isDraggingNode = true;
                    this.draggedNode = targetNode;
                    
                    const rect = this.container.getBoundingClientRect();
                    this.nodeDragStart = {
                        x: touch.clientX - rect.left,
                        y: touch.clientY - rect.top
                    };
                }
            }
            
            startDiscoveryAnimation() {
                // Clean up and add new messages
                setInterval(() => {
                    this.discoveryMessages = this.discoveryMessages.filter(msg => 
                        Date.now() - msg.startTime < msg.duration
                    );
                    
                    // Add random discovery messages between existing nodes
                    const activeNodes = Array.from(this.nodes.values()).filter(n => n.isAlive && n.type !== 'discovering');
                    if (activeNodes.length > 1 && Math.random() < 0.15) {
                        const source = activeNodes[Math.floor(Math.random() * activeNodes.length)];
                        const target = activeNodes[Math.floor(Math.random() * activeNodes.length)];
                        
                        if (source !== target) {
                            this.addDiscoveryMessage(source, target, 'discovery');
                        }
                    }
                }, 1200);
                
                // Background keepalive/health traffic
                setInterval(() => {
                    this.generateBackgroundTraffic();
                }, 2000);
                
                // Periodic hierarchy validation and self-correction
                setInterval(() => {
                    this.validateNodeHierarchy();
                }, 8000);
                
                // Smooth animation loop
                const animateMessages = () => {
                    this.updateDiscoveryMessages();
                    requestAnimationFrame(animateMessages);
                };
                animateMessages();
            }
            
            generateBackgroundTraffic() {
                const activeNodes = Array.from(this.nodes.values()).filter(n => n.isAlive && n.type !== 'discovering');
                if (activeNodes.length < 2) return;
                
                // 1. Parent-child health checks (most common)
                if (Math.random() < 0.7) {
                    const nodesWithParents = activeNodes.filter(n => n.parent);
                    if (nodesWithParents.length > 0) {
                        const node = nodesWithParents[Math.floor(Math.random() * nodesWithParents.length)];
                        this.addDiscoveryMessage(node, node.parent, 'health', null, 800);
                        
                        // Parent responds
                        setTimeout(() => {
                            this.addDiscoveryMessage(node.parent, node, 'health-response', null, 600);
                        }, 200 + Math.random() * 100);
                    }
                }
                
                // 2. Mainframe node status broadcasts (periodic)
                if (Math.random() < 0.3) {
                    const mainframeNodes = activeNodes.filter(n => n.type === 'mainframe');
                    if (mainframeNodes.length > 0) {
                        const mainframe = mainframeNodes[Math.floor(Math.random() * mainframeNodes.length)];
                        const children = activeNodes.filter(n => n.parent === mainframe);
                        
                        children.forEach((child, index) => {
                            setTimeout(() => {
                                this.addDiscoveryMessage(mainframe, child, 'status-broadcast', null, 1000);
                            }, index * 50);
                        });
                    }
                }
                
                // 3. Peer-to-peer keepalives between siblings
                if (Math.random() < 0.4) {
                    // Find nodes with the same parent
                    const nodesByParent = {};
                    activeNodes.filter(n => n.parent).forEach(node => {
                        const parentId = node.parent.id;
                        if (!nodesByParent[parentId]) nodesByParent[parentId] = [];
                        nodesByParent[parentId].push(node);
                    });
                    
                    // Pick a parent with multiple children
                    const parentIds = Object.keys(nodesByParent).filter(pid => nodesByParent[pid].length > 1);
                    if (parentIds.length > 0) {
                        const parentId = parentIds[Math.floor(Math.random() * parentIds.length)];
                        const siblings = nodesByParent[parentId];
                        const source = siblings[Math.floor(Math.random() * siblings.length)];
                        const targets = siblings.filter(s => s !== source);
                        
                        if (targets.length > 0) {
                            const target = targets[Math.floor(Math.random() * targets.length)];
                            this.addDiscoveryMessage(source, target, 'peer-keepalive', null, 700);
                        }
                    }
                }
                
                // 4. Capacity status checks (less frequent)
                if (Math.random() < 0.2) {
                    const nonTerminalNodes = activeNodes.filter(n => n.type !== 'terminal' && n.children.length > 0);
                    if (nonTerminalNodes.length > 0) {
                        const parent = nonTerminalNodes[Math.floor(Math.random() * nonTerminalNodes.length)];
                        const children = parent.children.filter(c => c.isAlive);
                        
                        if (children.length > 0) {
                            const child = children[Math.floor(Math.random() * children.length)];
                            this.addDiscoveryMessage(parent, child, 'capacity-check', null, 900);
                        }
                    }
                }
            }
            
            validateNodeHierarchy() {
                const activeNodes = Array.from(this.nodes.values()).filter(n => 
                    n.isAlive && n.type !== 'discovering' && n.type !== 'mainframe'
                );
                
                activeNodes.forEach(node => {
                    if (!node.parent) return; // Skip orphaned nodes, they'll be handled elsewhere
                    
                    const isValid = this.isValidHierarchy(node, node.parent);
                    const isParentOverloaded = node.parent.children.length > node.parent.capacity;
                    const isUnderutilized = this.isNodeUnderutilized(node);
                    
                    if (!isValid) {
                        this.logEvent(`${node.id} HIERARCHY VIOLATION DETECTED: ${node.type} → ${node.parent.type}`, 'warning');
                        
                        // Check if node can self-promote to fix the hierarchy
                        if (this.canSelfPromote(node)) {
                            this.performSelfPromotion(node);
                        } else {
                            // Rerun discovery to find correct position
                            this.logEvent(`${node.id} INITIATING CORRECTIVE DISCOVERY`, 'info');
                            this.rerunNodeDiscovery(node);
                        }
                    } else if (isParentOverloaded) {
                        this.logEvent(`${node.id} PARENT OVERLOADED: ${node.parent.id} (${node.parent.children.length}/${node.parent.capacity})`, 'warning');
                        
                        // Rerun discovery to find less congested parent
                        this.logEvent(`${node.id} SEEKING LOAD-BALANCED PARENT`, 'info');
                        this.rerunNodeDiscovery(node);
                    } else if (isUnderutilized) {
                        this.logEvent(`${node.id} UNDERUTILIZED: No children for extended period`, 'warning');
                        
                        // Consider demotion or repositioning
                        if (this.shouldDemoteNode(node)) {
                            this.performNodeDemotion(node);
                        } else {
                            // Try to find a better position
                            this.logEvent(`${node.id} SEEKING MORE USEFUL POSITION`, 'info');
                            this.rerunNodeDiscovery(node);
                        }
                    }
                });
            }
            
            isValidHierarchy(node, parent) {
                // Valid hierarchy rules:
                // Terminal → Node
                // Node → Relay  
                // Relay → Mainframe
                
                if (node.type === 'terminal' && parent.type === 'node') return true;
                if (node.type === 'node' && parent.type === 'relay') return true;
                if (node.type === 'relay' && parent.type === 'mainframe') return true;
                
                return false;
            }
            
            canSelfPromote(node) {
                // A node can self-promote if its parent's type suggests it should be promoted
                // Example: Terminal attached to Relay should become Node
                // Example: Node attached to Mainframe should become Relay
                
                if (node.type === 'terminal' && node.parent.type === 'relay') {
                    // Should become a Node under this Relay
                    return node.parent.children.length < node.parent.capacity;
                }
                
                if (node.type === 'node' && node.parent.type === 'mainframe') {
                    // Should become a Relay under this Mainframe
                    return node.parent.children.length < node.parent.capacity;
                }
                
                return false;
            }
            
            performSelfPromotion(node) {
                let newType = '';
                let newCapacity = 0;
                
                if (node.type === 'terminal' && node.parent.type === 'relay') {
                    newType = 'node';
                    newCapacity = this.capacities.node;
                } else if (node.type === 'node' && node.parent.type === 'mainframe') {
                    newType = 'relay';
                    newCapacity = this.capacities.relay;
                }
                
                if (newType) {
                    this.logEvent(`${node.id} SELF-PROMOTING: ${node.type.toUpperCase()} → ${newType.toUpperCase()}`, 'success');
                    
                    node.type = newType;
                    node.capacity = newCapacity;
                    
                    // Visual confirmation
                    this.addDiscoveryMessage(node, node.parent, 'self-promote', null, 800);
                    
                    this.updateVisualization();
                    this.updateStats();
                }
            }
            
            rerunNodeDiscovery(node) {
                // Disconnect from current parent
                if (node.parent) {
                    node.parent.children = node.parent.children.filter(c => c !== node);
                }
                
                // Reset node to discovery state
                node.parent = null;
                node.type = 'discovering';
                node.discoveryState = 'probing';
                node.discoveryResponses = [];
                node.discoveryStartTime = Date.now();
                node.capacity = 0;
                
                // Restart discovery process
                this.startNodeDiscovery(node);
            }
            
            isNodeUnderutilized(node) {
                // Only check intermediate nodes (relay, node) that could have children
                if (node.type === 'terminal' || node.type === 'mainframe') return false;
                
                // Check if node has been childless for a while
                if (node.children.length === 0) {
                    // Initialize timestamp if not exists
                    if (!node.lastChildlessCheck) {
                        node.lastChildlessCheck = Date.now();
                        return false;
                    }
                    
                    // Consider underutilized if childless for more than 25 seconds
                    const childlessDuration = Date.now() - node.lastChildlessCheck;
                    return childlessDuration > 25000;
                } else {
                    // Reset timestamp when node has children
                    node.lastChildlessCheck = null;
                    return false;
                }
            }
            
            shouldDemoteNode(node) {
                // Check if there are already enough intermediate nodes of this type
                const sameTypeNodes = Array.from(this.nodes.values()).filter(n => 
                    n.isAlive && n.type === node.type && n !== node
                );
                
                // Also check if there are available positions for terminals at lower levels
                const availableTerminalSlots = this.countAvailableTerminalSlots();
                
                // Demote if there are other nodes of same type and available terminal slots
                return sameTypeNodes.length > 0 && availableTerminalSlots > 0;
            }
            
            countAvailableTerminalSlots() {
                const nodeTypeNodes = Array.from(this.nodes.values()).filter(n => 
                    n.isAlive && n.type === 'node'
                );
                
                let availableSlots = 0;
                nodeTypeNodes.forEach(node => {
                    availableSlots += Math.max(0, node.capacity - node.children.length);
                });
                
                return availableSlots;
            }
            
            performNodeDemotion(node) {
                this.logEvent(`${node.id} SELF-DEMOTING: ${node.type.toUpperCase()} → TERMINAL`, 'info');
                
                // Visual confirmation
                this.addDiscoveryMessage(node, node.parent, 'demote', null, 800);
                
                // Demote to terminal and rerun discovery
                node.type = 'terminal';
                node.capacity = 0;
                
                // Force rediscovery to find appropriate parent
                this.rerunNodeDiscovery(node);
            }
            
            addNode() {
                const nodeId = `NODE-${this.nodeIdCounter.toString().padStart(3, '0')}`;
                this.nodeIdCounter++;
                
                const location = {
                    lat: (Math.random() * 160) - 80,
                    lon: (Math.random() * 340) - 170
                };
                
                const node = {
                    id: nodeId,
                    type: 'discovering',
                    location: location,
                    label: nodeId.replace('NODE-', ''),
                    parent: null,
                    children: [],
                    capacity: 0,
                    depth: 0,
                    isAlive: true,
                    x: this.getInitialNodePosition().x,
                    y: this.getInitialNodePosition().y,
                    discoveryState: 'probing',
                    discoveryResponses: [],
                    discoveryStartTime: Date.now()
                };
                
                this.nodes.set(nodeId, node);
                this.logEvent(`${nodeId} MATERIALIZED - INITIATING DISCOVERY SEQUENCE`, 'warning');
                
                // Start discovery process
                this.startNodeDiscovery(node);
                
                this.updateVisualization();
                this.updateStats();
            }
            
            addMultipleNodes(count) {
                this.logEvent(`MASS NODE INJECTION INITIATED - ${count} UNITS`, 'info');
                for (let i = 0; i < count; i++) {
                    setTimeout(() => this.addNode(), i * 400);
                }
            }
            
            startNodeDiscovery(node) {
                // Step 1: Contact all mainframe nodes for topology information
                const mainframeNodes = Array.from(this.nodes.values()).filter(n => n.type === 'mainframe' && n.isAlive);
                
                if (mainframeNodes.length === 0) {
                    this.logEvent(`${node.id} DISCOVERY ABORT - NO MAINFRAME NODES DETECTED`, 'error');
                    this.nodes.delete(node.id);
                    return;
                }
                
                this.logEvent(`${node.id} SCANNING ${mainframeNodes.length} MAINFRAME NODES FOR TOPOLOGY DATA`, 'info');
                
                let mainframeResponses = [];
                mainframeNodes.forEach((mainframe, index) => {
                    setTimeout(() => {
                        this.addDiscoveryMessage(node, mainframe, 'topology-request', () => {
                            const latency = this.calculateLatency(node.location, mainframe.location);
                            const responseDelay = latency + Math.random() * 30;
                            
                            setTimeout(() => {
                                this.addDiscoveryMessage(mainframe, node, 'topology-response', () => {
                                    mainframeResponses.push({
                                        mainframe: mainframe,
                                        latency: latency,
                                        topology: this.getNetworkTopology(mainframe)
                                    });
                                    
                                    this.logEvent(`${node.id} RX TOPOLOGY FROM ${mainframe.id} (${latency}ms)`, 'info');
                                    
                                    if (mainframeResponses.length === mainframeNodes.length) {
                                        this.processTopologyResponses(node, mainframeResponses);
                                    }
                                });
                            }, responseDelay);
                        });
                    }, index * 200);
                });
                
                // Timeout for topology discovery
                setTimeout(() => {
                    if (node.discoveryState === 'probing' && mainframeResponses.length > 0) {
                        this.processTopologyResponses(node, mainframeResponses);
                    } else if (mainframeResponses.length === 0) {
                        this.logEvent(`${node.id} DISCOVERY TIMEOUT - NO TOPOLOGY RESPONSES`, 'error');
                        this.nodes.delete(node.id);
                        this.updateVisualization();
                        this.updateStats();
                    }
                }, this.discoveryTimeout);
            }
            
            getNetworkTopology(mainframe) {
                const topology = {
                    relays: [],
                    nodes: [],
                    capacityInfo: {}
                };
                
                const getAllDescendants = (node) => {
                    let descendants = [node];
                    node.children.forEach(child => {
                        descendants = descendants.concat(getAllDescendants(child));
                    });
                    return descendants;
                };
                
                const descendants = getAllDescendants(mainframe);
                
                descendants.forEach(node => {
                    if (node.type === 'relay') {
                        topology.relays.push({
                            id: node.id,
                            latency: this.calculateLatency(mainframe.location, node.location),
                            capacity: node.capacity,
                            used: node.children.length
                        });
                    } else if (node.type === 'node') {
                        topology.nodes.push({
                            id: node.id,
                            parentId: node.parent.id,
                            latency: this.calculateLatency(mainframe.location, node.location),
                            capacity: node.capacity,
                            used: node.children.length
                        });
                    }
                    
                    topology.capacityInfo[node.id] = {
                        capacity: node.capacity,
                        used: node.children.length,
                        available: node.capacity - node.children.length
                    };
                });
                
                return topology;
            }
            
            processTopologyResponses(node, mainframeResponses) {
                mainframeResponses.sort((a, b) => a.latency - b.latency);
                const bestMainframe = mainframeResponses[0];
                
                this.logEvent(`${node.id} SELECTED ${bestMainframe.mainframe.id} AS PRIMARY MAINFRAME (${bestMainframe.latency}ms)`, 'success');
                
                const topology = bestMainframe.topology;
                let candidates = [];
                
                // 1. Try to become a Terminal (attach to available nodes)
                topology.nodes.forEach(nodeEntry => {
                    const targetNode = this.nodes.get(nodeEntry.id);
                    if (targetNode && targetNode.type === 'node' && targetNode.children.length < targetNode.capacity) {
                        candidates.push({
                            node: targetNode,
                            newType: 'terminal',
                            priority: 1,
                            latency: this.calculateLatency(node.location, targetNode.location)
                        });
                    }
                });
                
                // 2. Try to become a Node (attach to available relays)
                if (candidates.length === 0) {
                    topology.relays.forEach(relay => {
                        const relayNode = this.nodes.get(relay.id);
                        if (relayNode && relayNode.type === 'relay' && relayNode.children.length < relayNode.capacity) {
                            candidates.push({
                                node: relayNode,
                                newType: 'node',
                                priority: 2,
                                latency: this.calculateLatency(node.location, relayNode.location)
                            });
                        }
                    });
                }
                
                // 3. Try to become a Relay (attach to mainframe)
                if (candidates.length === 0) {
                    if (bestMainframe.mainframe.type === 'mainframe' && bestMainframe.mainframe.children.length < bestMainframe.mainframe.capacity) {
                        candidates.push({
                            node: bestMainframe.mainframe,
                            newType: 'relay',
                            priority: 3,
                            latency: bestMainframe.latency
                        });
                    }
                }
                
                if (candidates.length === 0) {
                    this.logEvent(`${node.id} ATTACHMENT FAILED - NETWORK AT CAPACITY`, 'error');
                    this.nodes.delete(node.id);
                    this.updateVisualization();
                    this.updateStats();
                    return;
                }
                
                candidates.sort((a, b) => {
                    if (a.priority !== b.priority) return a.priority - b.priority;
                    return a.latency - b.latency;
                });
                
                const bestCandidate = candidates[0];
                this.attachNodeToParent(node, bestCandidate.node);
                node.type = bestCandidate.newType;
                
                if (node.type === 'relay') node.capacity = this.capacities.relay;
                else if (node.type === 'node') node.capacity = this.capacities.node;
                else node.capacity = 0;
                
                this.logEvent(`${node.id} INTEGRATED AS ${node.type.toUpperCase()} → ${bestCandidate.node.id} (${bestCandidate.latency}ms)`, 'success');
                
                // Send final attachment messages
                this.addDiscoveryMessage(node, bestCandidate.node, 'attach');
                setTimeout(() => {
                    this.addDiscoveryMessage(bestCandidate.node, node, 'confirm');
                }, 300);
                
                this.updateVisualization();
                this.updateStats();
            }
            
            attachNodeToParent(node, parent) {
                node.parent = parent;
                parent.children.push(node);
                node.depth = parent.depth + 1;
                node.discoveryState = 'connected';
                
                // Position near parent with some spread (only for free-form view)
                if (this.viewMode === 'free') {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 80 + Math.random() * 40;
                    node.x = parent.x + Math.cos(angle) * distance;
                    node.y = parent.y + Math.sin(angle) * distance;
                } else {
                    // For other views, layout will be handled by layoutNodes()
                    this.layoutNodes();
                }
            }
            
            calculateLatency(loc1, loc2) {
                const R = 6371;
                const dLat = (loc2.lat - loc1.lat) * Math.PI / 180;
                const dLon = (loc2.lon - loc1.lon) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                          Math.cos(loc1.lat * Math.PI / 180) * Math.cos(loc2.lat * Math.PI / 180) *
                          Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                const distance = R * c;
                return Math.floor(distance / 100);
            }
            
            runDiscoveryRound() {
                this.logEvent('INITIATING DISCOVERY PROTOCOL ROUND...', 'warning');
                const currentTime = Date.now();
                
                const eligibleNodes = Array.from(this.nodes.values()).filter(n => 
                    n.isAlive && 
                    n.type !== 'mainframe' && 
                    n.type !== 'discovering' && 
                    n.parent &&
                    (!n.lastMigration || currentTime - n.lastMigration > this.migrationCooldown)
                );
                
                if (eligibleNodes.length === 0) {
                    this.logEvent('NO NODES ELIGIBLE FOR DISCOVERY ROUND', 'info');
                    return;
                }
                
                this.logEvent(`DISCOVERY ROUND: ${eligibleNodes.length} NODES PROBING NETWORK`, 'info');
                
                // Process each eligible node through the full discovery protocol
                eligibleNodes.forEach((node, index) => {
                    setTimeout(() => {
                        this.runNodeDiscoveryOptimization(node);
                    }, index * 300); // Stagger the discovery rounds
                });
            }
            
            runNodeDiscoveryOptimization(node) {
                // Step 1: Contact all mainframe nodes for fresh topology information
                const mainframeNodes = Array.from(this.nodes.values()).filter(n => n.type === 'mainframe' && n.isAlive);
                
                this.logEvent(`${node.id} REQUESTING FRESH TOPOLOGY FROM ${mainframeNodes.length} MAINFRAMES`, 'info');
                
                let mainframeResponses = [];
                mainframeNodes.forEach((mainframe, index) => {
                    setTimeout(() => {
                        this.addDiscoveryMessage(node, mainframe, 'topology-request', () => {
                            const latency = this.calculateLatency(node.location, mainframe.location);
                            const responseDelay = latency + Math.random() * 30;
                            
                            setTimeout(() => {
                                this.addDiscoveryMessage(mainframe, node, 'topology-response', () => {
                                    mainframeResponses.push({
                                        mainframe: mainframe,
                                        latency: latency,
                                        topology: this.getNetworkTopology(mainframe)
                                    });
                                    
                                    this.logEvent(`${node.id} RX TOPOLOGY FROM ${mainframe.id} (${latency}ms)`, 'info');
                                    
                                    if (mainframeResponses.length === mainframeNodes.length) {
                                        this.processOptimizationResponses(node, mainframeResponses);
                                    }
                                });
                            }, responseDelay);
                        });
                    }, index * 200);
                });
            }
            
            processOptimizationResponses(node, rootResponses) {
                // Find the best optimization opportunity
                const currentLatency = this.calculateLatency(node.location, node.parent.location);
                let bestOptimization = null;
                
                rootResponses.forEach(response => {
                    const topology = response.topology;
                    
                    // Check branches for potential leaf attachment
                    topology.branches.forEach(branch => {
                        const branchNode = this.nodes.get(branch.id);
                        if (branchNode && branchNode !== node.parent && branchNode.children.length < branchNode.capacity) {
                            const newLatency = this.calculateLatency(node.location, branchNode.location);
                            const improvement = (currentLatency - newLatency) / currentLatency;
                            
                            if (improvement > this.migrationThreshold && (!bestOptimization || improvement > bestOptimization.improvement)) {
                                bestOptimization = {
                                    parent: branchNode,
                                    latency: newLatency,
                                    improvement: improvement,
                                    newType: 'leaf'
                                };
                            }
                        }
                    });
                    
                    // Check trunks for potential branch attachment
                    topology.trunks.forEach(trunk => {
                        const trunkNode = this.nodes.get(trunk.id);
                        if (trunkNode && trunkNode !== node.parent && trunkNode.children.length < trunkNode.capacity) {
                            const newLatency = this.calculateLatency(node.location, trunkNode.location);
                            const improvement = (currentLatency - newLatency) / currentLatency;
                            
                            if (improvement > this.migrationThreshold && (!bestOptimization || improvement > bestOptimization.improvement)) {
                                bestOptimization = {
                                    parent: trunkNode,
                                    latency: newLatency,
                                    improvement: improvement,
                                    newType: 'branch'
                                };
                            }
                        }
                    });
                    
                    // Check root for potential trunk attachment
                    if (response.root !== node.parent && response.root.children.length < response.root.capacity) {
                        const improvement = (currentLatency - response.latency) / currentLatency;
                        
                        if (improvement > this.migrationThreshold && (!bestOptimization || improvement > bestOptimization.improvement)) {
                            bestOptimization = {
                                parent: response.root,
                                latency: response.latency,
                                improvement: improvement,
                                newType: 'trunk'
                            };
                        }
                    }
                });
                
                if (bestOptimization && !this.wouldCreateCycle(node, bestOptimization.parent)) {
                    // Perform the migration with proper discovery traffic
                    const improvementPercent = (bestOptimization.improvement * 100).toFixed(1);
                    this.logEvent(`${node.id} MIGRATION APPROVED: +${improvementPercent}% EFFICIENCY → ${bestOptimization.parent.id}`, 'success');
                    
                    // Send migration request
                    this.addDiscoveryMessage(node, bestOptimization.parent, 'migrate', () => {
                        // Wait for confirmation
                        setTimeout(() => {
                            this.addDiscoveryMessage(bestOptimization.parent, node, 'confirm', () => {
                                // Perform the actual migration
                                this.migrateNode(node, bestOptimization.parent);
                                node.type = bestOptimization.newType;
                                node.lastMigration = Date.now();
                                
                                // Update capacity
                                if (node.type === 'relay') node.capacity = this.capacities.relay;
                                else if (node.type === 'node') node.capacity = this.capacities.node;
                                else node.capacity = 0;
                                
                                this.logEvent(`${node.id} MIGRATION COMPLETE: NOW ${node.type.toUpperCase()}`, 'success');
                                this.updateVisualization();
                                this.updateStats();
                            });
                        }, 300);
                    });
                } else {
                    this.logEvent(`${node.id} DISCOVERY COMPLETE: NO BENEFICIAL MIGRATIONS FOUND`, 'info');
                }
            }
            
            migrateNode(node, newParent) {
                if (node.parent) {
                    node.parent.children = node.parent.children.filter(c => c !== node);
                }
                
                node.parent = newParent;
                newParent.children.push(node);
                
                this.updateNodeDepth(node);
                
                // Smooth repositioning (only for free-form view)
                if (this.viewMode === 'free') {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 80 + Math.random() * 40;
                    node.x = newParent.x + Math.cos(angle) * distance;
                    node.y = newParent.y + Math.sin(angle) * distance;
                } else {
                    // For other views, layout will be handled by layoutNodes()
                    this.layoutNodes();
                }
            }
            
            updateNodeDepth(node) {
                if (node.parent) {
                    node.depth = node.parent.depth + 1;
                }
                node.children.forEach(child => {
                    this.updateNodeDepth(child);
                });
            }
            
            wouldCreateCycle(node, potentialParent) {
                let current = potentialParent;
                while (current) {
                    if (current === node) return true;
                    current = current.parent;
                }
                return false;
            }
            
            setViewMode(mode) {
                this.viewMode = mode;
                this.logEvent(`VIEW MODE CHANGED TO ${mode.toUpperCase()}`, 'info');
                this.layoutNodes();
                this.updateVisualization();
            }
            
            adjustZoom(delta) {
                const newZoom = Math.max(0.2, Math.min(3.0, this.zoom + delta));
                if (newZoom !== this.zoom) {
                    // Get viewport center in screen coordinates
                    const containerRect = this.container.getBoundingClientRect();
                    const viewportCenterX = containerRect.width / 2;
                    const viewportCenterY = containerRect.height / 2;
                    
                    // Convert viewport center to world coordinates before zoom
                    const worldCenterX = (viewportCenterX - this.viewOffset.x) / this.zoom;
                    const worldCenterY = (viewportCenterY - this.viewOffset.y) / this.zoom;
                    
                    // Update zoom
                    this.zoom = newZoom;
                    
                    // Adjust viewOffset so the same world point stays at viewport center
                    this.viewOffset.x = viewportCenterX - (worldCenterX * this.zoom);
                    this.viewOffset.y = viewportCenterY - (worldCenterY * this.zoom);
                    
                    document.getElementById('zoomValue').textContent = Math.round(this.zoom * 100) + '%';
                    this.updateVisualization();
                }
            }
            
            layoutNodes() {
                const nodes = Array.from(this.nodes.values());
                const containerWidth = 800;
                const containerHeight = 600;
                
                switch (this.viewMode) {
                    case 'radial':
                        this.layoutRadial(nodes, containerWidth, containerHeight);
                        break;
                    case 'tree':
                        this.layoutTree(nodes, containerWidth, containerHeight);
                        break;
                    case 'free':
                    default:
                        // Keep existing positions for free form
                        break;
                }
            }
            
            
            layoutRadial(nodes, width, height) {
                const centerX = width / 2;
                const centerY = height / 2;
                const mainframeNodes = nodes.filter(n => n.type === 'mainframe');
                
                // Place mainframes in center circle
                mainframeNodes.forEach((mainframe, index) => {
                    const angle = (index / mainframeNodes.length) * Math.PI * 2;
                    const radius = 60;
                    mainframe.x = centerX + Math.cos(angle) * radius;
                    mainframe.y = centerY + Math.sin(angle) * radius;
                });
                
                // Place other nodes in concentric circles by depth
                const nonMainframeNodes = nodes.filter(n => n.type !== 'mainframe');
                const maxDepth = Math.max(...nonMainframeNodes.map(n => n.depth), 0);
                
                for (let depth = 1; depth <= maxDepth; depth++) {
                    const depthNodes = nonMainframeNodes.filter(n => n.depth === depth);
                    const radius = 60 + depth * 80;
                    
                    depthNodes.forEach((node, index) => {
                        const angle = (index / depthNodes.length) * Math.PI * 2;
                        node.x = centerX + Math.cos(angle) * radius;
                        node.y = centerY + Math.sin(angle) * radius;
                    });
                }
            }
            
            layoutTree(nodes, width, height) {
                const mainframeNodes = nodes.filter(n => n.type === 'mainframe');
                const mainframeSpacing = width / (mainframeNodes.length + 1);
                
                // Place mainframes at bottom
                mainframeNodes.forEach((mainframe, index) => {
                    mainframe.x = mainframeSpacing * (index + 1);
                    mainframe.y = height - 80;
                    this.layoutTreeRecursive(mainframe, mainframe.x, mainframe.y, 150, height - 80);
                });
            }
            
            layoutTreeRecursive(node, centerX, baseY, availableWidth, maxY) {
                if (node.children.length === 0) return;
                
                const childSpacing = availableWidth / (node.children.length + 1);
                const childY = Math.max(baseY - 100, 50);
                
                node.children.forEach((child, index) => {
                    const childX = centerX - availableWidth/2 + childSpacing * (index + 1);
                    child.x = childX;
                    child.y = childY;
                    
                    // Recursively layout child's children
                    this.layoutTreeRecursive(child, childX, childY, childSpacing * 0.8, maxY);
                });
            }
            
            getInitialNodePosition() {
                switch (this.viewMode) {
                    case 'radial':
                        // Random position in outer ring
                        const centerX = 400;
                        const centerY = 300;
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 250 + Math.random() * 50;
                        return {
                            x: centerX + Math.cos(angle) * radius,
                            y: centerY + Math.sin(angle) * radius
                        };
                    case 'tree':
                        // Random position at top (will be repositioned during layout)
                        return {
                            x: Math.random() * 600 + 100,
                            y: 50 + Math.random() * 50
                        };
                    case 'free':
                    default:
                        return {
                            x: Math.random() * 500 + 100,
                            y: Math.random() * 300 + 200
                        };
                }
            }
            
            toggleAutoRun() {
                const btn = document.getElementById('autoRunBtn');
                if (this.autoRunInterval) {
                    clearInterval(this.autoRunInterval);
                    this.autoRunInterval = null;
                    btn.textContent = 'AUTO RUN';
                    this.logEvent('AUTO-EVOLUTION DISABLED', 'warning');
                } else {
                    this.autoRunInterval = setInterval(() => {
                        this.performAutoRunAction();
                    }, 2500);
                    btn.textContent = 'STOP AUTO';
                    this.logEvent('AUTO-EVOLUTION ENABLED - CHAOTIC NETWORK DYNAMICS ACTIVE', 'success');
                }
            }
            
            performAutoRunAction() {
                const activeNodes = Array.from(this.nodes.values()).filter(n => n.isAlive && n.type !== 'discovering');
                const nonMainframeNodes = activeNodes.filter(n => n.type !== 'mainframe');
                
                const rand = Math.random();
                
                if (rand < 0.15 && nonMainframeNodes.length > 3) {
                    // 15% chance: Random node failure
                    this.simulateNodeFailure();
                } else if (rand < 0.30) {
                    // 15% chance: Spawn cluster of nodes (2-4 nodes)
                    this.spawnNodeCluster();
                } else if (rand < 0.60) {
                    // 30% chance: Add single node
                    this.addNode();
                } else if (rand < 0.78) {
                    // 18% chance: Run discovery optimization
                    this.runDiscoveryRound();
                } else {
                    // 22% chance: Multiple simultaneous failures (chaos mode)
                    if (nonMainframeNodes.length > 6) {
                        this.simulateCascadeFailure();
                    } else {
                        this.addNode();
                    }
                }
            }
            
            simulateNodeFailure() {
                const nonMainframeNodes = Array.from(this.nodes.values()).filter(n => 
                    n.isAlive && n.type !== 'mainframe' && n.type !== 'discovering'
                );
                
                if (nonMainframeNodes.length === 0) return;
                
                const victimNode = nonMainframeNodes[Math.floor(Math.random() * nonMainframeNodes.length)];
                this.logEvent(`${victimNode.id} CRITICAL FAILURE - NODE GOING OFFLINE`, 'error');
                
                // Add some visual drama
                const nodeElement = this.container.querySelector(`[data-node-id="${victimNode.id}"]`);
                if (nodeElement) {
                    nodeElement.style.animation = 'nodeFailure 1s ease-out';
                }
                
                // Remove after visual effect
                setTimeout(() => {
                    this.removeNode(victimNode.id);
                }, 1000);
            }
            
            spawnNodeCluster() {
                const clusterSize = Math.floor(Math.random() * 3) + 2; // 2-4 nodes
                const clusterNames = ['ALPHA', 'BETA', 'GAMMA', 'DELTA', 'EPSILON', 'ZETA', 'ETA', 'THETA'];
                const clusterName = clusterNames[Math.floor(Math.random() * clusterNames.length)];
                
                this.logEvent(`CLUSTER SPAWN DETECTED - ${clusterSize} ${clusterName} UNITS MATERIALIZING`, 'success');
                
                // Spawn nodes in close proximity
                const baseLocation = {
                    lat: (Math.random() * 160) - 80,
                    lon: (Math.random() * 340) - 170
                };
                
                for (let i = 0; i < clusterSize; i++) {
                    setTimeout(() => {
                        const nodeId = `${clusterName}-${String.fromCharCode(65 + i)}-${this.nodeIdCounter.toString().padStart(3, '0')}`;
                        this.nodeIdCounter++;
                        
                        // Cluster nodes spawn near each other
                        const clusterLocation = {
                            lat: baseLocation.lat + (Math.random() * 20 - 10),
                            lon: baseLocation.lon + (Math.random() * 20 - 10)
                        };
                        
                        const node = {
                            id: nodeId,
                            type: 'discovering',
                            location: clusterLocation,
                            label: nodeId.split('-')[1] + i,
                            parent: null,
                            children: [],
                            capacity: 0,
                            depth: 0,
                            isAlive: true,
                            x: this.getClusterNodePosition(baseLocation, i).x,
                            y: this.getClusterNodePosition(baseLocation, i).y,
                            discoveryState: 'probing',
                            discoveryResponses: [],
                            discoveryStartTime: Date.now()
                        };
                        
                        this.nodes.set(nodeId, node);
                        this.logEvent(`${nodeId} CLUSTER UNIT ONLINE - INITIATING DISCOVERY`, 'warning');
                        
                        // Start discovery process
                        this.startNodeDiscovery(node);
                        
                        this.updateVisualization();
                        this.updateStats();
                    }, i * 300); // Stagger cluster spawning
                }
            }
            
            getClusterNodePosition(baseLocation, index) {
                if (this.viewMode === 'free') {
                    // Spawn in a small circle pattern
                    const angle = (index / 4) * Math.PI * 2;
                    const radius = 60 + Math.random() * 30;
                    const centerX = 300 + Math.random() * 200;
                    const centerY = 200 + Math.random() * 200;
                    
                    return {
                        x: centerX + Math.cos(angle) * radius,
                        y: centerY + Math.sin(angle) * radius
                    };
                } else {
                    return this.getInitialNodePosition();
                }
            }
            
            simulateCascadeFailure() {
                const nonMainframeNodes = Array.from(this.nodes.values()).filter(n => 
                    n.isAlive && n.type !== 'mainframe' && n.type !== 'discovering'
                );
                
                if (nonMainframeNodes.length < 3) return;
                
                const failureCount = Math.min(3, Math.floor(nonMainframeNodes.length * 0.3));
                this.logEvent(`CASCADE FAILURE DETECTED - ${failureCount} NODES COMPROMISED`, 'error');
                
                // Select random nodes for failure
                const victims = [];
                for (let i = 0; i < failureCount; i++) {
                    const remaining = nonMainframeNodes.filter(n => !victims.includes(n));
                    if (remaining.length > 0) {
                        victims.push(remaining[Math.floor(Math.random() * remaining.length)]);
                    }
                }
                
                // Stagger the failures for dramatic effect
                victims.forEach((victim, index) => {
                    setTimeout(() => {
                        this.logEvent(`${victim.id} CASCADE VICTIM - SYSTEM FAILURE`, 'error');
                        this.removeNode(victim.id);
                    }, index * 500);
                });
            }
            
            resetNetwork() {
                if (this.autoRunInterval) {
                    this.toggleAutoRun();
                }
                
                this.nodes.clear();
                this.nodeIdCounter = 1;
                this.discoveryMessages = [];
                this.initializeMainframes();
                
                this.updateVisualization();
                this.updateStats();
                this.logEvent('SYNTH TREE MATRIX RESET - ALL MAINFRAMES RESTORED', 'warning');
            }
            
            addDiscoveryMessage(source, target, type, callback = null, customDuration = null) {
                let duration;
                if (customDuration !== null) {
                    duration = customDuration;
                } else {
                    // Default durations by message type
                    switch (type) {
                        case 'topology-request': duration = 1500; break;
                        case 'topology-response': duration = 1000; break;
                        case 'health': duration = 800; break;
                        case 'health-response': duration = 600; break;
                        case 'status-broadcast': duration = 1000; break;
                        case 'peer-keepalive': duration = 700; break;
                        case 'capacity-check': duration = 900; break;
                        default: duration = 2000; break;
                    }
                }
                
                const message = {
                    id: Math.random(),
                    source: source,
                    target: target,
                    startTime: Date.now(),
                    duration: duration,
                    type: type,
                    callback: callback
                };
                
                this.discoveryMessages.push(message);
                
                if (callback) {
                    setTimeout(callback, message.duration);
                }
            }
            
            updateDiscoveryMessages() {
                const container = this.container;
                
                container.querySelectorAll('.discovery-message').forEach(el => el.remove());
                
                this.discoveryMessages.forEach(msg => {
                    const progress = (Date.now() - msg.startTime) / msg.duration;
                    if (progress >= 1) return;
                    
                    const x = msg.source.x + (msg.target.x - msg.source.x) * progress;
                    const y = msg.source.y + (msg.target.y - msg.source.y) * progress;
                    
                    const element = document.createElement('div');
                    element.className = `discovery-message ${msg.type}`;
                    const scaledX = (x * this.zoom) + this.viewOffset.x;
                    const scaledY = (y * this.zoom) + this.viewOffset.y;
                    element.style.left = scaledX + 'px';
                    element.style.top = scaledY + 'px';
                    element.style.transform = `scale(${this.zoom})`;
                    element.style.opacity = 1 - progress * 0.5;
                    
                    container.appendChild(element);
                });
            }
            
            updateVisualization() {
                const container = this.container;
                
                container.querySelectorAll('.node, .connection').forEach(el => el.remove());
                
                const nodes = Array.from(this.nodes.values()).filter(n => n.isAlive);
                
                // Draw connections first
                nodes.forEach(node => {
                    if (node.parent) {
                        const connection = document.createElement('div');
                        connection.className = 'connection';
                        
                        const dx = node.x - node.parent.x;
                        const dy = node.y - node.parent.y;
                        const length = Math.sqrt(dx*dx + dy*dy);
                        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                        
                        const scaledParentX = (node.parent.x * this.zoom) + this.viewOffset.x;
                        const scaledParentY = (node.parent.y * this.zoom) + this.viewOffset.y;
                        const scaledLength = length * this.zoom;
                        
                        connection.style.left = scaledParentX + 'px';
                        connection.style.top = scaledParentY + 'px';
                        connection.style.width = scaledLength + 'px';
                        connection.style.transform = `rotate(${angle}deg) scaleY(${this.zoom})`;
                        
                        container.appendChild(connection);
                    }
                });
                
                // Draw nodes
                nodes.forEach(node => {
                    const element = document.createElement('div');
                    element.className = `node node-${node.type}`;
                    element.textContent = node.label;
                    const scaledX = (node.x * this.zoom) - 16 + this.viewOffset.x;
                    const scaledY = (node.y * this.zoom) - 16 + this.viewOffset.y;
                    element.style.left = scaledX + 'px';
                    element.style.top = scaledY + 'px';
                    element.style.transform = `scale(${this.zoom})`;
                    
                    // Add click to remove and dragging cursor
                    if (node.type !== 'mainframe') {
                        element.addEventListener('click', (e) => {
                            if (!this.isDraggingNode) {
                                this.removeNode(node.id);
                            }
                        });
                        
                        if (this.viewMode === 'free') {
                            element.classList.add('node-draggable');
                            element.style.cursor = 'grab';
                        }
                    }
                    
                    // Add data attribute for easier node identification
                    element.setAttribute('data-node-id', node.id);
                    
                    container.appendChild(element);
                });
            }
            
            removeNode(nodeId) {
                const node = this.nodes.get(nodeId);
                if (!node || node.type === 'mainframe') return;
                
                const orphans = [...node.children];
                
                if (node.parent) {
                    node.parent.children = node.parent.children.filter(c => c !== node);
                }
                
                this.nodes.delete(nodeId);
                
                // Reattach orphans using discovery process
                orphans.forEach(orphan => {
                    orphan.parent = null;
                    orphan.type = 'discovering';
                    orphan.discoveryState = 'probing';
                    orphan.discoveryResponses = [];
                    orphan.discoveryStartTime = Date.now();
                    this.startNodeDiscovery(orphan);
                });
                
                this.logEvent(`${nodeId} TERMINATED - ${orphans.length} ORPHANS REASSIGNING`, 'warning');
                this.updateVisualization();
                this.updateStats();
            }
            
            updateStats() {
                const stats = { total: 0, mainframe: 0, relay: 0, node: 0, terminal: 0, discovering: 0, depths: [] };
                
                for (const [id, nodeEntry] of this.nodes) {
                    if (!nodeEntry.isAlive) continue;
                    stats.total++;
                    if (nodeEntry.type === 'discovering') {
                        stats.discovering++;
                    } else {
                        stats[nodeEntry.type]++;
                        if (nodeEntry.type !== 'mainframe') stats.depths.push(nodeEntry.depth);
                    }
                }
                
                const avgDepth = stats.depths.length > 0 
                    ? (stats.depths.reduce((a, b) => a + b, 0) / stats.depths.length).toFixed(2)
                    : '0.00';
                
                document.getElementById('totalNodes').textContent = stats.total;
                document.getElementById('mainframeNodes').textContent = stats.mainframe;
                document.getElementById('relayNodes').textContent = stats.relay;
                document.getElementById('nodeNodes').textContent = stats.node;
                document.getElementById('terminalNodes').textContent = stats.terminal;
                document.getElementById('avgDepth').textContent = avgDepth;
            }
            
            logEvent(message, type = 'info') {
                const log = document.getElementById('eventLog');
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                
                const time = new Date().toLocaleTimeString();
                entry.innerHTML = `
                    <span class="log-time">${time}</span>
                    <span class="log-message ${type}">${message}</span>
                `;
                
                log.insertBefore(entry, log.firstChild);
                
                while (log.children.length > 20) {
                    log.removeChild(log.lastChild);
                }
            }
        }

        // Initialize simulation when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('SYNTH TREE MATRIX BOOTSTRAP SEQUENCE INITIATED...');
            window.simulation = new DiscoverySimulation();
        });
    </script>
</body>
</html>