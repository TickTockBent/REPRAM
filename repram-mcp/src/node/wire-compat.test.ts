/**
 * Wire compatibility tests — P1g (#52)
 *
 * Validates that the TypeScript implementation produces and consumes
 * wire-compatible JSON with the Go implementation. Test vectors are
 * generated by Go's encoding/json with the exact struct definitions
 * from internal/gossip/http_transport.go.
 *
 * Categories:
 *  1. Go JSON → TS deserialization (TS can parse Go output)
 *  2. TS JSON → Go deserialization (TS produces parseable output)
 *  3. HMAC cross-verification (same secret + same bytes = same sig)
 *  4. Bootstrap wire format parity
 *  5. Edge cases (binary data, empty enclave, omitempty)
 */

import { describe, it, expect } from "vitest";
import { messageToWire, wireToMessage } from "./transport.js";
import { signBody, verifyBody } from "./auth.js";
import type { Message, WireMessage, NodeInfo } from "./types.js";

// ─── Go-generated test vectors ──────────────────────────────────────
// These strings are the EXACT output of Go's json.Marshal for the
// SimpleMessage struct. Field order follows Go struct declaration order.

const GO_VECTORS = {
  /** TV1: Full PUT with all fields + NodeInfo */
  PUT_FULL: '{"type":"PUT","from":"node-1","to":"node-2","key":"test-key","data":"aGVsbG8gd29ybGQ=","ttl":300,"timestamp":1700000000,"message_id":"1700000000000000000-1","node_info":{"id":"node-1","address":"192.168.1.1","port":9090,"http_port":8080,"enclave":"production"}}',

  /** TV2: PING with To field */
  PING: '{"type":"PING","from":"node-1","to":"node-2","timestamp":1700000000,"message_id":"1700000000000000000-2"}',

  /** TV3: SYNC with NodeInfo, no to/key/data */
  SYNC: '{"type":"SYNC","from":"node-1","timestamp":1700000000,"message_id":"1700000000000000000-3","node_info":{"id":"node-3","address":"10.0.0.3","port":9092,"http_port":8082,"enclave":"default"}}',

  /** TV4: ACK referencing a PUT MessageID */
  ACK: '{"type":"ACK","from":"node-2","to":"node-1","key":"test-key","timestamp":1700000001,"message_id":"1700000000000000000-1"}',

  /** TV5: PONG with NodeInfo (no enclave — omitempty) */
  PONG_NO_ENCLAVE: '{"type":"PONG","from":"node-2","to":"node-1","timestamp":1700000000,"message_id":"1700000000000000000-4","node_info":{"id":"node-2","address":"10.0.0.2","port":9091,"http_port":8081}}',

  /** TV6: PUT with binary data [0x00, 0xFF, 0x80, 0x01] */
  PUT_BINARY: '{"type":"PUT","from":"node-1","key":"binary-key","data":"AP+AAQ==","ttl":60,"timestamp":1700000000,"message_id":"1700000000000000000-5"}',

  /** TV7: SYNC from pre-enclave node (no enclave in NodeInfo) */
  SYNC_NO_ENCLAVE: '{"type":"SYNC","from":"node-old","timestamp":1700000000,"message_id":"1700000000000000000-6","node_info":{"id":"node-old","address":"10.0.0.99","port":9090,"http_port":8080}}',

  /** TV8: Bootstrap request */
  BOOTSTRAP: '{"node_id":"new-node","address":"10.0.0.50","gossip_port":9090,"http_port":8080,"enclave":"default"}',
};

/** HMAC signatures computed by Go's SignBody with secret "test-cluster-secret" */
const GO_HMAC = {
  PUT_FULL: "ef8821f774e8eacef35c1482b1e6e216fe9d49759dfbcea2ced801fb7e3b83b9",
  PING: "a6f9ae4d77e73d5e6654eb511661d192a7ac9e051d58bdbd67fc5800ca37bb94",
  SYNC: "12607334a6ce57c711ec51ba2e014b0fbf162a9e9838b161118bd5acd8a46a2e",
  ACK: "b05f9c1fbe8ede866aac08c1ebf4566a26e97244b53dc9be0dc24585063f7856",
  PONG_NO_ENCLAVE: "7d24ef3cbce3443e2d82d26cf75ccaee1c8f4ae5ec88b9fa82c4f452813d95af",
  PUT_BINARY: "f1134102d05cb885ce18bcc56ac07bf415e75dc60510cb3674c251e9fddf0157",
  BOOTSTRAP: "4dd92fb021ff7e4b811a432bbaec845686cc67b72b9016c8d8488f0324485cc7",
};

const HMAC_SECRET = "test-cluster-secret";

// ─── Category 1: Go JSON → TS deserialization ───────────────────────

describe("Go → TS: deserialization", () => {
  it("TV1: full PUT with all fields", () => {
    const wire: WireMessage = JSON.parse(GO_VECTORS.PUT_FULL);
    const msg = wireToMessage(wire);

    expect(msg.type).toBe("PUT");
    expect(msg.from).toBe("node-1");
    expect(msg.to).toBe("node-2");
    expect(msg.key).toBe("test-key");
    expect(msg.data.toString("utf-8")).toBe("hello world");
    expect(msg.ttl).toBe(300);
    expect(msg.timestamp.getTime()).toBe(1700000000 * 1000);
    expect(msg.messageId).toBe("1700000000000000000-1");

    expect(msg.nodeInfo).toBeDefined();
    expect(msg.nodeInfo!.id).toBe("node-1");
    expect(msg.nodeInfo!.address).toBe("192.168.1.1");
    expect(msg.nodeInfo!.port).toBe(9090);
    expect(msg.nodeInfo!.httpPort).toBe(8080);
    expect(msg.nodeInfo!.enclave).toBe("production");
  });

  it("TV2: PING with minimal fields", () => {
    const wire: WireMessage = JSON.parse(GO_VECTORS.PING);
    const msg = wireToMessage(wire);

    expect(msg.type).toBe("PING");
    expect(msg.from).toBe("node-1");
    expect(msg.to).toBe("node-2");
    expect(msg.key).toBe("");       // omitted in Go → default ""
    expect(msg.data.length).toBe(0); // omitted in Go → empty buffer
    expect(msg.ttl).toBe(0);         // omitted in Go → default 0
    expect(msg.nodeInfo).toBeUndefined();
  });

  it("TV3: SYNC with NodeInfo", () => {
    const wire: WireMessage = JSON.parse(GO_VECTORS.SYNC);
    const msg = wireToMessage(wire);

    expect(msg.type).toBe("SYNC");
    expect(msg.to).toBe("");        // omitted in Go
    expect(msg.nodeInfo).toBeDefined();
    expect(msg.nodeInfo!.id).toBe("node-3");
    expect(msg.nodeInfo!.enclave).toBe("default");
  });

  it("TV4: ACK with MessageID reference", () => {
    const wire: WireMessage = JSON.parse(GO_VECTORS.ACK);
    const msg = wireToMessage(wire);

    expect(msg.type).toBe("ACK");
    expect(msg.from).toBe("node-2");
    expect(msg.to).toBe("node-1");
    expect(msg.key).toBe("test-key");
    expect(msg.messageId).toBe("1700000000000000000-1"); // references PUT
    expect(msg.data.length).toBe(0);
  });

  it("TV5: PONG with NodeInfo (no enclave)", () => {
    const wire: WireMessage = JSON.parse(GO_VECTORS.PONG_NO_ENCLAVE);
    const msg = wireToMessage(wire);

    expect(msg.type).toBe("PONG");
    expect(msg.nodeInfo).toBeDefined();
    expect(msg.nodeInfo!.id).toBe("node-2");
    // Missing enclave should default to "default"
    expect(msg.nodeInfo!.enclave).toBe("default");
  });

  it("TV6: PUT with binary data", () => {
    const wire: WireMessage = JSON.parse(GO_VECTORS.PUT_BINARY);
    const msg = wireToMessage(wire);

    expect(msg.type).toBe("PUT");
    expect(msg.key).toBe("binary-key");
    // Verify exact binary content: [0x00, 0xFF, 0x80, 0x01]
    expect(msg.data.length).toBe(4);
    expect(msg.data[0]).toBe(0x00);
    expect(msg.data[1]).toBe(0xff);
    expect(msg.data[2]).toBe(0x80);
    expect(msg.data[3]).toBe(0x01);
  });

  it("TV7: SYNC from pre-enclave node (backwards compat)", () => {
    const wire: WireMessage = JSON.parse(GO_VECTORS.SYNC_NO_ENCLAVE);
    const msg = wireToMessage(wire);

    expect(msg.nodeInfo).toBeDefined();
    expect(msg.nodeInfo!.id).toBe("node-old");
    // No enclave → should default to "default"
    expect(msg.nodeInfo!.enclave).toBe("default");
  });
});

// ─── Category 2: TS → Go deserializability ──────────────────────────
// Verify that TS-produced JSON has the correct field names and types
// so Go's json.Unmarshal(SimpleMessage{}) would succeed.

describe("TS → Go: serialization produces valid wire format", () => {
  it("full PUT message has all required fields", () => {
    const msg: Message = {
      type: "PUT",
      from: "node-1",
      to: "node-2",
      key: "test-key",
      data: Buffer.from("hello world"),
      ttl: 300,
      timestamp: new Date(1700000000 * 1000),
      messageId: "1700000000000000000-1",
      nodeInfo: {
        id: "node-1",
        address: "192.168.1.1",
        port: 9090,
        httpPort: 8080,
        enclave: "production",
      },
    };

    const wire = messageToWire(msg);
    const json = JSON.parse(JSON.stringify(wire));

    // Verify all field names match Go's JSON tags
    expect(json.type).toBe("PUT");
    expect(json.from).toBe("node-1");
    expect(json.to).toBe("node-2");
    expect(json.key).toBe("test-key");
    expect(json.data).toBe("aGVsbG8gd29ybGQ="); // base64 matching Go
    expect(json.ttl).toBe(300);
    expect(json.timestamp).toBe(1700000000);
    expect(json.message_id).toBe("1700000000000000000-1");

    // NodeInfo field names match Go's JSON tags
    expect(json.node_info.id).toBe("node-1");
    expect(json.node_info.address).toBe("192.168.1.1");
    expect(json.node_info.port).toBe(9090);
    expect(json.node_info.http_port).toBe(8080);
    expect(json.node_info.enclave).toBe("production");
  });

  it("omits empty fields (matches Go omitempty)", () => {
    const msg: Message = {
      type: "SYNC",
      from: "node-1",
      to: "",
      key: "",
      data: Buffer.alloc(0),
      ttl: 0,
      timestamp: new Date(1700000000 * 1000),
      messageId: "1700000000000000000-3",
      nodeInfo: {
        id: "node-3",
        address: "10.0.0.3",
        port: 9092,
        httpPort: 8082,
        enclave: "default",
      },
    };

    const wire = messageToWire(msg);
    const jsonStr = JSON.stringify(wire);
    const json = JSON.parse(jsonStr);

    // These should be omitted (matching Go's omitempty behavior)
    expect(json.to).toBeUndefined();
    expect(json.key).toBeUndefined();
    expect(json.data).toBeUndefined();
    expect(json.ttl).toBeUndefined();

    // These should always be present
    expect(json.type).toBeDefined();
    expect(json.from).toBeDefined();
    expect(json.timestamp).toBeDefined();
    expect(json.message_id).toBeDefined();
    expect(json.node_info).toBeDefined();
  });

  it("omits enclave from NodeInfo when empty (matches Go omitempty)", () => {
    const msg: Message = {
      type: "PONG",
      from: "node-2",
      to: "node-1",
      key: "",
      data: Buffer.alloc(0),
      ttl: 0,
      timestamp: new Date(1700000000 * 1000),
      messageId: "1700000000000000000-4",
      nodeInfo: {
        id: "node-2",
        address: "10.0.0.2",
        port: 9091,
        httpPort: 8081,
        enclave: "",  // empty → should be omitted
      },
    };

    const wire = messageToWire(msg);
    const json = JSON.parse(JSON.stringify(wire));

    expect(json.node_info.enclave).toBeUndefined();
  });

  it("base64-encodes binary data identically to Go", () => {
    const msg: Message = {
      type: "PUT",
      from: "node-1",
      to: "",
      key: "binary-key",
      data: Buffer.from([0x00, 0xff, 0x80, 0x01]),
      ttl: 60,
      timestamp: new Date(1700000000 * 1000),
      messageId: "1700000000000000000-5",
    };

    const wire = messageToWire(msg);
    // Go produces "AP+AAQ==" for []byte{0x00, 0xFF, 0x80, 0x01}
    expect(wire.data).toBe("AP+AAQ==");
  });

  it("timestamp is Unix epoch seconds (not milliseconds)", () => {
    const msg: Message = {
      type: "PING",
      from: "node-1",
      to: "node-2",
      key: "",
      data: Buffer.alloc(0),
      ttl: 0,
      timestamp: new Date("2023-11-14T22:13:20.000Z"), // 1700000000
      messageId: "test-id",
    };

    const wire = messageToWire(msg);
    expect(wire.timestamp).toBe(1700000000);
  });

  it("roundtrip: TS → wire → TS preserves all fields", () => {
    const original: Message = {
      type: "PUT",
      from: "node-1",
      to: "node-2",
      key: "test-key",
      data: Buffer.from("hello world"),
      ttl: 300,
      timestamp: new Date(1700000000 * 1000),
      messageId: "1700000000000000000-1",
      nodeInfo: {
        id: "node-1",
        address: "192.168.1.1",
        port: 9090,
        httpPort: 8080,
        enclave: "production",
      },
    };

    const wire = messageToWire(original);
    const jsonStr = JSON.stringify(wire);
    const parsed: WireMessage = JSON.parse(jsonStr);
    const restored = wireToMessage(parsed);

    expect(restored.type).toBe(original.type);
    expect(restored.from).toBe(original.from);
    expect(restored.to).toBe(original.to);
    expect(restored.key).toBe(original.key);
    expect(restored.data.equals(original.data)).toBe(true);
    expect(restored.ttl).toBe(original.ttl);
    expect(restored.timestamp.getTime()).toBe(original.timestamp.getTime());
    expect(restored.messageId).toBe(original.messageId);
    expect(restored.nodeInfo!.id).toBe(original.nodeInfo!.id);
    expect(restored.nodeInfo!.enclave).toBe(original.nodeInfo!.enclave);
  });

  it("roundtrip: Go JSON → TS → wire → JSON preserves data integrity", () => {
    // Parse Go output
    const goWire: WireMessage = JSON.parse(GO_VECTORS.PUT_FULL);
    const msg = wireToMessage(goWire);

    // Re-serialize through TS
    const tsWire = messageToWire(msg);
    const tsJson = JSON.parse(JSON.stringify(tsWire));

    // All values must match (field ORDER may differ, but values are identical)
    expect(tsJson.type).toBe(goWire.type);
    expect(tsJson.from).toBe(goWire.from);
    expect(tsJson.to).toBe(goWire.to);
    expect(tsJson.key).toBe(goWire.key);
    expect(tsJson.data).toBe(goWire.data);
    expect(tsJson.ttl).toBe(goWire.ttl);
    expect(tsJson.timestamp).toBe(goWire.timestamp);
    expect(tsJson.message_id).toBe(goWire.message_id);
    expect(tsJson.node_info.id).toBe(goWire.node_info!.id);
    expect(tsJson.node_info.enclave).toBe(goWire.node_info!.enclave);
  });
});

// ─── Category 3: HMAC cross-verification ─────────────────────────────
// Verify that TS's signBody/verifyBody produce identical results to Go's.

describe("HMAC cross-verification", () => {
  it("TS verifies Go-signed PUT", () => {
    const body = Buffer.from(GO_VECTORS.PUT_FULL);
    expect(verifyBody(HMAC_SECRET, body, GO_HMAC.PUT_FULL)).toBe(true);
  });

  it("TS verifies Go-signed PING", () => {
    const body = Buffer.from(GO_VECTORS.PING);
    expect(verifyBody(HMAC_SECRET, body, GO_HMAC.PING)).toBe(true);
  });

  it("TS verifies Go-signed SYNC", () => {
    const body = Buffer.from(GO_VECTORS.SYNC);
    expect(verifyBody(HMAC_SECRET, body, GO_HMAC.SYNC)).toBe(true);
  });

  it("TS verifies Go-signed ACK", () => {
    const body = Buffer.from(GO_VECTORS.ACK);
    expect(verifyBody(HMAC_SECRET, body, GO_HMAC.ACK)).toBe(true);
  });

  it("TS verifies Go-signed PONG", () => {
    const body = Buffer.from(GO_VECTORS.PONG_NO_ENCLAVE);
    expect(verifyBody(HMAC_SECRET, body, GO_HMAC.PONG_NO_ENCLAVE)).toBe(true);
  });

  it("TS verifies Go-signed binary PUT", () => {
    const body = Buffer.from(GO_VECTORS.PUT_BINARY);
    expect(verifyBody(HMAC_SECRET, body, GO_HMAC.PUT_BINARY)).toBe(true);
  });

  it("TS produces identical signatures to Go", () => {
    // Sign the same bytes and compare
    expect(signBody(HMAC_SECRET, Buffer.from(GO_VECTORS.PUT_FULL)))
      .toBe(GO_HMAC.PUT_FULL);
    expect(signBody(HMAC_SECRET, Buffer.from(GO_VECTORS.PING)))
      .toBe(GO_HMAC.PING);
    expect(signBody(HMAC_SECRET, Buffer.from(GO_VECTORS.SYNC)))
      .toBe(GO_HMAC.SYNC);
    expect(signBody(HMAC_SECRET, Buffer.from(GO_VECTORS.ACK)))
      .toBe(GO_HMAC.ACK);
  });

  it("TS rejects tampered Go-signed message", () => {
    const tampered = GO_VECTORS.PUT_FULL.replace("node-1", "node-X");
    expect(verifyBody(HMAC_SECRET, Buffer.from(tampered), GO_HMAC.PUT_FULL)).toBe(false);
  });

  it("TS rejects wrong secret", () => {
    expect(verifyBody("wrong-secret", Buffer.from(GO_VECTORS.PUT_FULL), GO_HMAC.PUT_FULL)).toBe(false);
  });

  it("TS verifies Go-signed bootstrap request", () => {
    const body = Buffer.from(GO_VECTORS.BOOTSTRAP);
    expect(verifyBody(HMAC_SECRET, body, GO_HMAC.BOOTSTRAP)).toBe(true);
  });

  it("TS signs bootstrap request identically to Go", () => {
    expect(signBody(HMAC_SECRET, Buffer.from(GO_VECTORS.BOOTSTRAP)))
      .toBe(GO_HMAC.BOOTSTRAP);
  });
});

// ─── Category 4: Bootstrap wire format ───────────────────────────────

describe("Bootstrap wire format", () => {
  it("TS bootstrap request matches Go field names", () => {
    // This is what the TS bootstrap module would produce
    const request = {
      node_id: "new-node",
      address: "10.0.0.50",
      gossip_port: 9090,
      http_port: 8080,
      enclave: "default",
    };

    const tsJson = JSON.parse(JSON.stringify(request));
    const goJson = JSON.parse(GO_VECTORS.BOOTSTRAP);

    expect(tsJson.node_id).toBe(goJson.node_id);
    expect(tsJson.address).toBe(goJson.address);
    expect(tsJson.gossip_port).toBe(goJson.gossip_port);
    expect(tsJson.http_port).toBe(goJson.http_port);
    expect(tsJson.enclave).toBe(goJson.enclave);
  });

  it("Go bootstrap response is parseable by TS", () => {
    // Simulated Go bootstrap response
    const goResponse = JSON.stringify({
      success: true,
      peers: [
        { id: "node-1", address: "10.0.0.1", port: 9090, http_port: 8080, enclave: "default" },
        { id: "node-2", address: "10.0.0.2", port: 9091, http_port: 8081, enclave: "default" },
      ],
    });

    const parsed = JSON.parse(goResponse);
    expect(parsed.success).toBe(true);
    expect(parsed.peers).toHaveLength(2);

    // Convert to NodeInfo (same as wireToNodeInfo does)
    const peer = parsed.peers[0];
    const nodeInfo: NodeInfo = {
      id: peer.id,
      address: peer.address,
      port: peer.port,
      httpPort: peer.http_port,
      enclave: peer.enclave ?? "default",
    };
    expect(nodeInfo.id).toBe("node-1");
    expect(nodeInfo.httpPort).toBe(8080);
    expect(nodeInfo.enclave).toBe("default");
  });
});

// ─── Category 5: Edge cases ──────────────────────────────────────────

describe("Wire format edge cases", () => {
  it("empty data field: Go omits, TS handles absence", () => {
    // Go with empty Data (nil []byte) omits the field
    const goJson = '{"type":"PING","from":"a","timestamp":0,"message_id":"x"}';
    const msg = wireToMessage(JSON.parse(goJson));
    expect(msg.data.length).toBe(0);
    expect(Buffer.isBuffer(msg.data)).toBe(true);
  });

  it("empty string base64: TS handles gracefully", () => {
    // Edge case: data field present but empty string
    const json = '{"type":"PUT","from":"a","data":"","timestamp":0,"message_id":"x"}';
    const msg = wireToMessage(JSON.parse(json));
    expect(msg.data.length).toBe(0);
  });

  it("Go ttl is int32, TS handles large values", () => {
    const json = '{"type":"PUT","from":"a","ttl":86400,"timestamp":0,"message_id":"x"}';
    const msg = wireToMessage(JSON.parse(json));
    expect(msg.ttl).toBe(86400);
  });

  it("Go timestamp 0 is handled correctly", () => {
    const json = '{"type":"PING","from":"a","timestamp":0,"message_id":"x"}';
    const msg = wireToMessage(JSON.parse(json));
    expect(msg.timestamp.getTime()).toBe(0);
  });

  it("extra fields from Go are ignored by TS", () => {
    // Future Go versions might add fields — TS should not choke
    const json = '{"type":"PUT","from":"a","timestamp":0,"message_id":"x","future_field":"ignored"}';
    const msg = wireToMessage(JSON.parse(json));
    expect(msg.type).toBe("PUT");
    expect(msg.from).toBe("a");
  });

  it("TS base64 padding matches Go standard encoding", () => {
    // Go uses standard base64 with padding (not URL-safe, not raw)
    // Test various padding cases
    const cases = [
      { input: [0x61],             expected: "YQ==" },       // 1 byte → 2 padding
      { input: [0x61, 0x62],       expected: "YWI=" },       // 2 bytes → 1 padding
      { input: [0x61, 0x62, 0x63], expected: "YWJj" },       // 3 bytes → no padding
      { input: [0x00],             expected: "AA==" },       // null byte
      { input: [0xff, 0xfe],       expected: "//4=" },       // high bytes (standard, not URL-safe)
    ];

    for (const { input, expected } of cases) {
      const buf = Buffer.from(input);
      expect(buf.toString("base64")).toBe(expected);
    }
  });

  it("TS can handle Go's standard base64 with + and /", () => {
    // Go uses standard base64 (not URL-safe), which includes + and /
    // Ensure TS can decode these
    const goBase64 = "//4="; // [0xFF, 0xFE] in standard base64
    const decoded = Buffer.from(goBase64, "base64");
    expect(decoded[0]).toBe(0xff);
    expect(decoded[1]).toBe(0xfe);
  });
});
