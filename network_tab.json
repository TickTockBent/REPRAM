{
  "log": {
    "version": "1.2",
    "creator": {
      "name": "Firefox",
      "version": "139.0.1"
    },
    "browser": {
      "name": "Firefox",
      "version": "139.0.1"
    },
    "pages": [
      {
        "id": "page_1",
        "pageTimings": {
          "onContentLoad": 92,
          "onLoad": 109
        },
        "startedDateTime": "2025-06-11T08:55:09.325-04:00",
        "title": "http://192.168.68.60:3000/fade/"
      }
    ],
    "entries": [
      {
        "startedDateTime": "2025-06-11T08:55:09.338-04:00",
        "request": {
          "bodySize": 0,
          "method": "GET",
          "url": "http://192.168.68.60:3000/fade/",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Host",
              "value": "192.168.68.60:3000"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:139.0) Gecko/20100101 Firefox/139.0"
            },
            {
              "name": "Accept",
              "value": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Cookie",
              "value": "CookieConsent=false; cookieConsent=false"
            },
            {
              "name": "Upgrade-Insecure-Requests",
              "value": "1"
            },
            {
              "name": "If-Modified-Since",
              "value": "Wed, 11 Jun 2025 12:18:53 GMT"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"11411060-8557-2025-06-11T12:18:53.797Z\""
            },
            {
              "name": "Priority",
              "value": "u=0, i"
            }
          ],
          "cookies": [
            {
              "name": "CookieConsent",
              "value": "false"
            },
            {
              "name": "cookieConsent",
              "value": "false"
            }
          ],
          "queryString": [],
          "headersSize": 512
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "accept-ranges",
              "value": "bytes"
            },
            {
              "name": "cache-control",
              "value": "max-age=3600"
            },
            {
              "name": "last-modified",
              "value": "Wed, 11 Jun 2025 12:18:53 GMT"
            },
            {
              "name": "etag",
              "value": "W/\"11411060-8557-2025-06-11T12:18:53.797Z\""
            },
            {
              "name": "Date",
              "value": "Wed, 11 Jun 2025 12:55:09 GMT"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            }
          ],
          "cookies": [],
          "content": {
            "mimeType": "text/html; charset=UTF-8",
            "size": 8557,
            "text": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>fade.repram.io - Ephemeral Message Board</title>\n    <link rel=\"stylesheet\" href=\"styles.css\">\n</head>\n<body>\n    <div class=\"container\">\n        <header>\n            <pre class=\"ascii-art\">\n╔═══════════════════════════════════════════════════════════════╗\n║                                                               ║\n║              ███████╗ █████╗ ██████╗ ███████╗                ║\n║              ██╔════╝██╔══██╗██╔══██╗██╔════╝                ║\n║              █████╗  ███████║██║  ██║█████╗                  ║\n║              ██╔══╝  ██╔══██║██║  ██║██╔══╝                  ║\n║              ██║     ██║  ██║██████╔╝███████╗                ║\n║              ╚═╝     ╚═╝  ╚═╝╚═════╝ ╚══════╝                ║\n║                                                               ║\n╚═══════════════════════════════════════════════════════════════╝\n            </pre>\n            <h1>fade.repram.io</h1>\n            <div class=\"version-info\">Version: Spectral-Vortex 0.1</div>\n            <p class=\"tagline\">[ EPHEMERAL MESSAGE SYSTEM // DISTRIBUTED NETWORK ]</p>\n        </header>\n\n        <!-- Connection Status Indicator -->\n        <div class=\"connection-status\" id=\"connectionStatus\">\n            <div class=\"status-line\">\n                <span class=\"status-icon\" id=\"statusIcon\">◆</span>\n                <span class=\"status-text\" id=\"statusText\">INITIALIZING...</span>\n                <span class=\"node-info\" id=\"nodeInfo\"></span>\n                <div class=\"node-selector\" id=\"nodeSelector\">\n                    <select id=\"nodeSelect\" onchange=\"fadeClient.switchNode(this.value)\">\n                        <option value=\"\">Auto (Load Balance)</option>\n                        <option value=\"http://localhost:8080\" class=\"localhost-only\">Node 1 (8080)</option>\n                        <option value=\"http://localhost:8081\" class=\"localhost-only\">Node 2 (8081)</option>\n                        <option value=\"http://localhost:8082\" class=\"localhost-only\">Node 3 (8082)</option>\n                    </select>\n                </div>\n            </div>\n            <div class=\"scan-line\" id=\"scanLine\"></div>\n        </div>\n\n        <!-- Live Message Board -->\n        <div class=\"message-board\" id=\"messageBoard\">\n            <div class=\"loading\">Connecting to REPRAM network...</div>\n        </div>\n\n        <!-- Message Submission -->\n        <div class=\"input-area\">\n            <h3>TRANSMIT://MESSAGE</h3>\n            <textarea \n                id=\"messageInput\" \n                placeholder=\"ENTER MESSAGE > _\"\n                maxlength=\"280\" \n                rows=\"3\"\n            ></textarea>\n            <div class=\"callsign-controls\">\n                <input \n                    type=\"text\" \n                    id=\"callsignInput\" \n                    placeholder=\"CALLSIGN (OPTIONAL) > _\"\n                    maxlength=\"20\"\n                >\n                <input \n                    type=\"text\" \n                    id=\"locationInput\" \n                    placeholder=\"LOCATION (OPTIONAL) > _\"\n                    maxlength=\"30\"\n                >\n            </div>\n            <div class=\"input-controls\">\n                <span class=\"char-count\">Characters: <span id=\"charCount\">0</span>/280</span>\n                <div class=\"submit-controls\">\n                    <label for=\"ttlSelect\">Expires in:</label>\n                    <select id=\"ttlSelect\">\n                        <option value=\"1800\">30 minutes</option>\n                        <option value=\"3600\" selected>1 hour</option>\n                        <option value=\"21600\">6 hours</option>\n                        <option value=\"86400\">1 day</option>\n                        <option value=\"604800\">1 week</option>\n                    </select>\n                    <button id=\"sendButton\" onclick=\"submitMessage()\">TRANSMIT</button>\n                </div>\n            </div>\n            <div class=\"key-preview\">KEY PREVIEW: <span id=\"keyPreview\" onclick=\"fadeClient.copyToClipboard(this.textContent, event)\" title=\"Click to copy key\">-</span></div>\n            <div class=\"hint\">[NOTICE] MESSAGE WILL PROPAGATE GLOBALLY // TTL ENFORCED // NO ENCRYPTION</div>\n        </div>\n\n        <!-- Direct Message Lookup -->\n        <div class=\"input-area\">\n            <h3>RETRIEVE://MESSAGE_BY_KEY</h3>\n            <p class=\"description\">Every message gets a unique key. If someone shares a key with you, you can read that specific message. Unless it's already gone. Like tears in rain.</p>\n            <div class=\"lookup-controls\">\n                <input \n                    type=\"text\" \n                    id=\"keyInput\" \n                    placeholder=\"KEY > _\"\n                >\n                <button onclick=\"lookupMessage()\">RETRIEVE</button>\n            </div>\n            <div id=\"lookupResult\"></div>\n        </div>\n\n        <!-- Explanation -->\n        <div class=\"explanation\">\n            <h3>PROTOCOL://EPHEMERAL</h3>\n            <ul>\n                <li><strong>No accounts needed</strong> - just type and submit</li>\n                <li><strong>Messages spread globally</strong> - replicants take ~15 minutes to reach all nodes</li>\n                <li><strong>Everything disappears</strong> - automatic deletion when TTL expires</li>\n                <li><strong>Completely open</strong> - anyone can read, anyone can write</li>\n                <li><strong>Distributed network</strong> - no central server to shut down</li>\n            </ul>\n        </div>\n\n        <!-- Network Status -->\n        <div class=\"network-status\">\n            <h3>REPRAM Network Status</h3>\n            <div class=\"status-grid\">\n                <div class=\"status-item\">\n                    <strong>Active Nodes:</strong> <span id=\"nodeCount\">-</span>\n                </div>\n                <div class=\"status-item\">\n                    <strong>Live Messages:</strong> <span id=\"messageCount\">-</span>\n                </div>\n                <div class=\"status-item\">\n                    <strong>Messages Expired Today:</strong> <span id=\"expiredCount\">-</span>\n                </div>\n                <div class=\"status-item\">\n                    <strong>Current Node:</strong> <span id=\"currentNode\">-</span>\n                </div>\n            </div>\n            <div class=\"node-health\" id=\"nodeHealth\">\n                <h4>Node Health:</h4>\n                <div class=\"node-list\" id=\"nodeList\"></div>\n            </div>\n        </div>\n\n        <!-- Technical Info -->\n        <div class=\"input-area\">\n            <h3>TECHNICAL://SPECIFICATIONS</h3>\n            <p>This demo shows REPRAM's core functionality:</p>\n            <ul>\n                <li><strong>Pure key-value storage</strong> with automatic TTL expiration</li>\n                <li><strong>Gossip protocol replication</strong> across geographically distributed nodes</li>\n                <li><strong>Zero authentication</strong> - anyone can read/write data</li>\n                <li><strong>Client-side conventions</strong> for optional features (like callsigns)</li>\n                <li><strong>No encryption</strong> in demo mode - data is plaintext</li>\n            </ul>\n            <p>\n                <strong>Want to run your own node?</strong> \n                <a href=\"https://github.com/ticktockbent/repram\" target=\"_blank\">Check out the REPRAM repository</a>\n            </p>\n            <p>\n                <strong>Need encryption and compliance features?</strong> \n                The enterprise SDK provides client-side encryption, compliance attestations, and zero-trust architecture.\n            </p>\n        </div>\n        \n        <!-- Footer Version -->\n        <div class=\"footer-version\">FADE v0.1 \"Spectral-Vortex\" // REPRAM.io</div>\n    </div>\n\n    <script src=\"config.js\"></script>\n    <script src=\"client.js\"></script>\n</body>\n</html>"
          },
          "redirectURL": "",
          "headersSize": 260,
          "bodySize": 8817
        },
        "cache": {
          "afterRequest": null
        },
        "timings": {
          "blocked": 0,
          "dns": 0,
          "connect": 1,
          "ssl": 0,
          "send": 0,
          "wait": 1,
          "receive": 0
        },
        "time": 2,
        "_securityState": "insecure",
        "serverIPAddress": "192.168.68.60",
        "connection": "3000",
        "pageref": "page_1"
      },
      {
        "startedDateTime": "2025-06-11T08:55:09.345-04:00",
        "request": {
          "bodySize": 0,
          "method": "GET",
          "url": "http://192.168.68.60:3000/fade/styles.css",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Host",
              "value": "192.168.68.60:3000"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:139.0) Gecko/20100101 Firefox/139.0"
            },
            {
              "name": "Accept",
              "value": "text/css,*/*;q=0.1"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            }
          ],
          "cookies": [],
          "queryString": [],
          "headersSize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "accept-ranges",
              "value": "bytes"
            },
            {
              "name": "cache-control",
              "value": "max-age=3600"
            },
            {
              "name": "last-modified",
              "value": "Tue, 10 Jun 2025 16:45:59 GMT"
            },
            {
              "name": "etag",
              "value": "W/\"11411065-25393-2025-06-10T16:45:59.230Z\""
            },
            {
              "name": "content-length",
              "value": "25393"
            },
            {
              "name": "content-type",
              "value": "text/css; charset=UTF-8"
            },
            {
              "name": "Date",
              "value": "Wed, 11 Jun 2025 12:52:21 GMT"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            }
          ],
          "cookies": [],
          "content": {
            "mimeType": "text/css",
            "size": 25393,
            "text": ""
          },
          "redirectURL": "",
          "headersSize": 0,
          "bodySize": 0
        },
        "cache": {},
        "timings": {},
        "time": 0,
        "pageref": "page_1"
      },
      {
        "startedDateTime": "2025-06-11T08:55:09.362-04:00",
        "request": {
          "bodySize": 0,
          "method": "GET",
          "url": "http://192.168.68.60:3000/fade/config.js",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Host",
              "value": "192.168.68.60:3000"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:139.0) Gecko/20100101 Firefox/139.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Referer",
              "value": "http://192.168.68.60:3000/fade/"
            },
            {
              "name": "Cookie",
              "value": "CookieConsent=false; cookieConsent=false"
            }
          ],
          "cookies": [
            {
              "name": "CookieConsent",
              "value": "false"
            },
            {
              "name": "cookieConsent",
              "value": "false"
            }
          ],
          "queryString": [],
          "headersSize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "accept-ranges",
              "value": "bytes"
            },
            {
              "name": "cache-control",
              "value": "max-age=3600"
            },
            {
              "name": "last-modified",
              "value": "Wed, 11 Jun 2025 12:49:20 GMT"
            },
            {
              "name": "etag",
              "value": "W/\"11413611-2343-2025-06-11T12:49:20.244Z\""
            },
            {
              "name": "content-length",
              "value": "2343"
            },
            {
              "name": "content-type",
              "value": "application/javascript; charset=UTF-8"
            },
            {
              "name": "Date",
              "value": "Wed, 11 Jun 2025 12:52:21 GMT"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            }
          ],
          "cookies": [],
          "content": {
            "mimeType": "application/javascript; charset=UTF-8",
            "size": 2343,
            "text": "// Configuration for FADE demo\nconst FadeConfig = {\n    // API endpoint configuration\n    getApiBaseURL: function() {\n        // Check URL parameters first\n        const urlParams = new URLSearchParams(window.location.search);\n        const backend = urlParams.get('backend');\n        if (backend) {\n            console.log('Using backend from URL parameter:', backend);\n            return backend;\n        }\n        \n        // Check localStorage for saved backend\n        const savedBackend = localStorage.getItem('fade_backend_url');\n        if (savedBackend) {\n            console.log('Using saved backend:', savedBackend);\n            return savedBackend;\n        }\n        \n        // Default backends based on environment\n        if (window.location.hostname === 'fade.repram.io' || window.location.hostname === 'repram.io') {\n            // Production - use your dynamic DNS (HTTP for now, HTTPS later)\n            return 'http://repram.ddns.net:8081';\n        } else if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || \n                   window.location.hostname.startsWith('192.168.') || window.location.hostname.startsWith('10.') || \n                   window.location.hostname.startsWith('172.')) {\n            // Local development (localhost or private IP ranges)\n            return 'http://localhost:8081';\n        }\n        \n        // Fallback to same origin\n        return '';\n    },\n    \n    // Node endpoints (for direct connection)\n    getNodes: function() {\n        if (window.location.hostname === 'fade.repram.io' || window.location.hostname === 'repram.io') {\n            return [\n                'http://repram.ddns.net:8081',\n                'http://repram.ddns.net:8082', \n                'http://repram.ddns.net:8083'\n            ];\n        } else {\n            // Local development\n            return [\n                'http://localhost:8081',\n                'http://localhost:8082', \n                'http://localhost:8083'\n            ];\n        }\n    },\n    \n    // Connection mode\n    connectionMode: 'direct', // 'direct' to connect to nodes, 'proxy' to use fade server\n};\n\n// Helper to set custom backend\nwindow.setFadeBackend = function(url) {\n    localStorage.setItem('fade_backend_url', url);\n    console.log('Backend URL saved. Reload the page to use:', url);\n};"
          },
          "redirectURL": "",
          "headersSize": 0,
          "bodySize": 2343
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "ssl": 0,
          "connect": 0,
          "send": 0,
          "wait": 0,
          "receive": 0
        },
        "time": 0,
        "_securityState": "insecure",
        "pageref": "page_1"
      },
      {
        "startedDateTime": "2025-06-11T08:55:09.365-04:00",
        "request": {
          "bodySize": 0,
          "method": "GET",
          "url": "http://192.168.68.60:3000/fade/client.js",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Host",
              "value": "192.168.68.60:3000"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:139.0) Gecko/20100101 Firefox/139.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Referer",
              "value": "http://192.168.68.60:3000/fade/"
            },
            {
              "name": "Cookie",
              "value": "CookieConsent=false; cookieConsent=false"
            }
          ],
          "cookies": [
            {
              "name": "CookieConsent",
              "value": "false"
            },
            {
              "name": "cookieConsent",
              "value": "false"
            }
          ],
          "queryString": [],
          "headersSize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "accept-ranges",
              "value": "bytes"
            },
            {
              "name": "cache-control",
              "value": "max-age=3600"
            },
            {
              "name": "last-modified",
              "value": "Wed, 11 Jun 2025 12:52:11 GMT"
            },
            {
              "name": "etag",
              "value": "W/\"11411056-39258-2025-06-11T12:52:11.033Z\""
            },
            {
              "name": "content-length",
              "value": "39258"
            },
            {
              "name": "content-type",
              "value": "application/javascript; charset=UTF-8"
            },
            {
              "name": "Date",
              "value": "Wed, 11 Jun 2025 12:52:21 GMT"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            }
          ],
          "cookies": [],
          "content": {
            "mimeType": "application/javascript; charset=UTF-8",
            "size": 39258,
            "text": "// REPRAM Fade Client - Ephemeral Message Board\nclass RepramFadeClient {\n    constructor() {\n        // Use configuration to determine base URL\n        this.baseURL = typeof FadeConfig !== 'undefined' ? FadeConfig.getApiBaseURL() : '';\n        this.connectionMode = typeof FadeConfig !== 'undefined' ? FadeConfig.connectionMode : 'proxy';\n        this.nodes = typeof FadeConfig !== 'undefined' && FadeConfig.getNodes ? FadeConfig.getNodes() : [];\n        this.currentNodeIndex = 0;\n        \n        this.messages = new Map();\n        this.pollInterval = null;\n        this.ttlInterval = null;\n        this.connected = false;\n        \n        // Track expired messages\n        this.expiredToday = this.loadExpiredCount();\n        \n        // Load saved callsign and location\n        this.callsign = localStorage.getItem('fade_callsign') || '';\n        this.location = localStorage.getItem('fade_location') || '';\n        \n        // Preview key for next message\n        this.previewKey = null;\n        \n        // Track node information\n        this.nodes = [];\n        this.lastUsedNode = null;\n        this.preferredNode = null; // null means auto/load-balanced\n    }\n    \n    loadExpiredCount() {\n        // Load from localStorage with today's date as key\n        const today = new Date().toDateString();\n        const stored = localStorage.getItem(`fade_expired_${today}`);\n        return stored ? parseInt(stored) : 0;\n    }\n    \n    saveExpiredCount() {\n        const today = new Date().toDateString();\n        localStorage.setItem(`fade_expired_${today}`, this.expiredToday.toString());\n        \n        // Clean up old dates\n        const keys = Object.keys(localStorage);\n        keys.forEach(key => {\n            if (key.startsWith('fade_expired_') && !key.includes(today)) {\n                localStorage.removeItem(key);\n            }\n        });\n    }\n    \n    saveCallsign(callsign, location) {\n        this.callsign = callsign;\n        this.location = location;\n        localStorage.setItem('fade_callsign', callsign);\n        localStorage.setItem('fade_location', location);\n    }\n\n    async init() {\n        console.log('Initializing REPRAM Fade client...');\n        \n        // Update node selector labels based on connection mode\n        const select = document.getElementById('nodeSelect');\n        if (this.connectionMode === 'direct') {\n            // Direct mode - show node selection\n            select.options[0].text = 'Auto (Load Balance)';\n            select.options[1].text = 'Node 1 Direct';\n            select.options[2].text = 'Node 2 Direct';\n            select.options[3].text = 'Node 3 Direct';\n            \n            console.log('Direct connection mode - connecting to cluster nodes directly');\n        } else {\n            // Proxy mode\n            select.options[0].text = 'Auto (Round Robin)';\n            select.options[1].text = 'Prefer Node 1';\n            select.options[2].text = 'Prefer Node 2';\n            select.options[3].text = 'Prefer Node 3';\n            \n            console.log('Proxy mode via ' + window.location.hostname + ' - using proxy with node preference.');\n        }\n        \n        await this.connectToNode();\n        await this.loadRecentMessages();\n        this.startPolling();\n        this.startTTLUpdater();\n        this.updateNetworkStatus();\n    }\n\n    async connectToNode() {\n        try {\n            console.log('Attempting to connect to REPRAM network...');\n            \n            if (this.connectionMode === 'direct' && this.nodes.length > 0) {\n                // Direct connection to cluster nodes\n                for (let i = 0; i < this.nodes.length; i++) {\n                    const nodeUrl = this.nodes[this.currentNodeIndex];\n                    try {\n                        console.log('Trying direct connection to:', nodeUrl);\n                        const response = await fetch(`${nodeUrl}/health`, {\n                            method: 'GET',\n                            mode: 'cors'\n                        });\n                        \n                        if (response.ok) {\n                            this.baseURL = nodeUrl;\n                            this.connected = true;\n                            console.log('Connected to REPRAM network via direct connection:', nodeUrl);\n                            this.updateConnectionStatus('connected');\n                            await this.updateNodeStatus();\n                            return;\n                        }\n                    } catch (error) {\n                        console.log('Failed to connect to node:', nodeUrl, error.message);\n                    }\n                    \n                    // Try next node\n                    this.currentNodeIndex = (this.currentNodeIndex + 1) % this.nodes.length;\n                }\n                throw new Error('All direct nodes failed');\n            } else {\n                // Proxy mode\n                const headers = {};\n                if (this.preferredNode) {\n                    headers['X-Preferred-Node'] = this.preferredNode;\n                }\n                \n                const response = await fetch(`${this.baseURL}/api/health`, {\n                    method: 'GET',\n                    headers: headers\n                });\n                \n                console.log('Health check response:', response.status);\n                \n                if (response.ok) {\n                    this.connected = true;\n                    console.log('Connected to REPRAM network via proxy');\n                    this.updateConnectionStatus('connected');\n                    await this.updateNodeStatus();\n                    return;\n                } else {\n                    console.error('Health check failed with status:', response.status);\n                    this.updateConnectionStatus('error');\n                }\n            }\n        } catch (error) {\n            console.error('Failed to connect to REPRAM network:', error);\n            this.updateConnectionStatus('error');\n        }\n        \n        this.showError('Unable to connect to REPRAM network. Please try again later.');\n    }\n\n    async updateNodeStatus() {\n        try {\n            if (this.connectionMode === 'direct') {\n                // For direct connections, create status from configured nodes\n                this.nodeStatuses = [];\n                for (let i = 0; i < this.nodes.length; i++) {\n                    const nodeUrl = this.nodes[i];\n                    const isCurrentNode = nodeUrl === this.baseURL;\n                    this.nodeStatuses.push({\n                        id: `node-${i + 1}`,\n                        url: nodeUrl,\n                        healthy: isCurrentNode ? this.connected : false, // Only know current node status\n                        current: isCurrentNode\n                    });\n                }\n            } else if (this.selectedNode) {\n                // When directly connected, we only know about this one node\n                this.nodeStatuses = [{\n                    id: `node-${this.selectedNode.split(':').pop()}`,\n                    url: this.selectedNode,\n                    healthy: this.connected,\n                    current: true\n                }];\n            } else {\n                // Use the proxy's node status endpoint\n                const response = await fetch(`${this.baseURL}/api/nodes/status`);\n                if (response.ok) {\n                    this.nodeStatuses = await response.json();\n                }\n            }\n            this.updateNetworkDisplay();\n        } catch (error) {\n            console.error('Failed to fetch node status:', error);\n        }\n    }\n\n    updateNetworkDisplay() {\n        const nodes = this.nodeStatuses || [];\n        const activeNodes = nodes.filter(n => n.healthy).length;\n        document.getElementById('currentNode').textContent = `${activeNodes} nodes active`;\n        \n        // Update a more detailed display if needed\n        const nodeList = nodes.map(n => \n            `${n.id}: ${n.healthy ? '✓' : '✗'} ${n.current ? '(current)' : ''}`\n        ).join(', ');\n        console.log('Node status:', nodeList);\n    }\n\n    async submitMessage(content, ttl, callsign, location) {\n        if (!this.connected) {\n            await this.connectToNode();\n        }\n\n        // Use the pre-generated key from preview\n        const key = this.nextKey || this.generateKey();\n        \n        // Format message with callsign if provided\n        let formattedContent = content;\n        if (callsign) {\n            formattedContent = location ? `${content}|${callsign}|${location}` : `${content}|${callsign}|`;\n        }\n        \n        try {\n            // Using raw data endpoint with TTL in query parameter\n            const headers = {\n                'Content-Type': 'text/plain'\n            };\n            \n            // Add preferred node header if selected\n            if (this.preferredNode) {\n                headers['X-Preferred-Node'] = this.preferredNode;\n            }\n            \n            const endpoint = this.connectionMode === 'direct' ? \n                `${this.baseURL}/data/${key}?ttl=${parseInt(ttl)}` : \n                `${this.baseURL}/api/data/${key}?ttl=${parseInt(ttl)}`;\n                \n            const response = await fetch(endpoint, {\n                method: 'PUT',\n                headers: headers,\n                body: formattedContent  // Send raw text directly\n            });\n\n            if (response.ok) {\n                // Cluster nodes return plain text \"OK\", not JSON\n                const result = await response.text();\n                const actualKey = key; // Use the key we sent\n                \n                // Capture which node handled the request\n                const nodeId = response.headers.get('x-repram-node') || 'unknown';\n                const nodeUrl = response.headers.get('x-repram-node-url') || '';\n                this.lastUsedNode = { id: nodeId, url: nodeUrl };\n                \n                // Show immediate local feedback with node info\n                this.displayMessage(actualKey, formattedContent, ttl, nodeId);\n                \n                // Clear the nextKey so a new one is generated for the next message\n                this.nextKey = null;\n                \n                // Update node status periodically\n                await this.updateNodeStatus();\n                \n                return actualKey;\n            } else {\n                const errorText = await response.text();\n                console.error('Server error:', errorText);\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n        } catch (error) {\n            console.error('Failed to submit message:', error);\n            throw error;\n        }\n    }\n\n    async getMessage(key) {\n        if (!this.connected) {\n            await this.connectToNode();\n        }\n\n        try {\n            // Using standard data endpoint\n            const url = this.connectionMode === 'direct' ? \n                `${this.baseURL}/data/${encodeURIComponent(key)}` : \n                `${this.baseURL}/api/data/${encodeURIComponent(key)}`;\n            const response = await fetch(url);\n            \n            if (response.ok) {\n                // Response is raw text data\n                const content = await response.text();\n                \n                // Capture which node served this\n                const nodeId = response.headers.get('x-repram-node') || null;\n                \n                return {\n                    content: content,\n                    ttl: 3600, // Default TTL since cluster nodes don't return it\n                    remaining_ttl: 3600,\n                    nodeId: nodeId\n                };\n            } else if (response.status === 404) {\n                return null; // Message expired or doesn't exist\n            } else {\n                throw new Error(`HTTP ${response.status}`);\n            }\n        } catch (error) {\n            console.error('Failed to get message:', error);\n            return null;\n        }\n    }\n\n    async loadRecentMessages() {\n        const board = document.getElementById('messageBoard');\n        \n        // Clear loading message\n        const loading = board.querySelector('.loading');\n        if (loading) {\n            loading.remove();\n        }\n        \n        if (!this.connected) {\n            return;\n        }\n        \n        try {\n            // Try to scan for existing messages on the node\n            const headers = {};\n            if (this.preferredNode) {\n                headers['X-Preferred-Node'] = this.preferredNode;\n            }\n            \n            const scanEndpoint = this.connectionMode === 'direct' ? \n                `${this.baseURL}/scan` : \n                `${this.baseURL}/api/scan`;\n            const scanResponse = await fetch(scanEndpoint, {\n                method: 'GET',\n                headers: headers\n            });\n            \n            if (scanResponse.ok) {\n                const scanResult = await scanResponse.json();\n                console.log('Found keys on node:', scanResult.keys);\n                \n                // Load messages for discovered keys (limit to recent 20 to avoid overwhelming)\n                const keysToLoad = scanResult.keys ? scanResult.keys.slice(-20) : [];\n                for (const key of keysToLoad) {\n                    if (!this.messages.has(key)) {\n                        const message = await this.getMessage(key);\n                        if (message) {\n                            this.displayMessage(key, message.content, message.remaining_ttl, message.nodeId, true);\n                        }\n                    }\n                }\n            } else {\n                console.log('Scan not available or failed, messages will appear when created');\n            }\n            \n            // Show welcome message if no messages and no welcome message already exists\n            if (this.messages.size === 0 && !board.querySelector('.welcome-message')) {\n                const welcomeDiv = document.createElement('div');\n                welcomeDiv.className = 'message welcome-message';\n                welcomeDiv.style.textAlign = 'center';\n                welcomeDiv.style.opacity = '0.7';\n                welcomeDiv.innerHTML = `\n                    <div class=\"message-content\">\n                        <strong>Welcome to FADE</strong><br>\n                        Send the first message or use a key to retrieve existing messages.<br>\n                        <em>Messages are ephemeral and will fade away after their TTL expires.</em>\n                    </div>\n                `;\n                board.appendChild(welcomeDiv);\n            }\n        } catch (error) {\n            console.error('Failed to load messages:', error);\n        }\n    }\n\n    generateKey() {\n        // Fun word lists for generating memorable keys\n        const adjectives = [\n            'quantum', 'electric', 'neon', 'cyber', 'phantom', 'cosmic', 'digital', \n            'spectral', 'holographic', 'virtual', 'glitched', 'synthetic', 'atomic',\n            'fractal', 'binary', 'ethereal', 'temporal', 'neural', 'prismatic',\n            'indolent', 'zealous', 'cryptic', 'arcane', 'volatile', 'emergent'\n        ];\n        \n        const nouns = [\n            'phoenix', 'serpent', 'wraith', 'specter', 'oracle', 'nexus', 'matrix',\n            'cipher', 'enigma', 'paradox', 'vortex', 'daemon', 'entity', 'phantom',\n            'baboon', 'raven', 'mantis', 'sphinx', 'hydra', 'chimera', 'basilisk',\n            'construct', 'artifact', 'anomaly', 'singularity', 'protocol', 'algorithm'\n        ];\n        \n        const adj = adjectives[Math.floor(Math.random() * adjectives.length)];\n        const noun = nouns[Math.floor(Math.random() * nouns.length)];\n        const timestamp = Date.now() * 1000000; // Convert to nanoseconds (approximate)\n        const random = Math.floor(Math.random() * 1000);\n        \n        return `msg-${adj}-${noun}-${timestamp}${random}`;\n    }\n    \n    generatePreviewKey() {\n        // Generate the actual key that will be used\n        if (!this.nextKey) {\n            this.nextKey = this.generateKey();\n        }\n        return this.nextKey;\n    }\n\n    parseMessage(raw) {\n        const parts = raw.split('|');\n        return {\n            content: parts[0] || raw,\n            callsign: parts[1] || null,\n            location: parts[2] || null\n        };\n    }\n\n    displayMessage(key, rawMessage, remainingTTL, nodeId = null, isRetrieved = false) {\n        // Avoid duplicates\n        if (this.messages.has(key)) return;\n\n        const parsed = this.parseMessage(rawMessage);\n        const messageData = {\n            parsed,\n            remainingTTL: parseInt(remainingTTL),\n            element: null,\n            timestamp: Date.now(),\n            isRetrieved: isRetrieved,\n            nodeId: nodeId\n        };\n        \n        this.messages.set(key, messageData);\n\n        const messageDiv = document.createElement('div');\n        messageDiv.className = parsed.callsign ? 'message community' : 'message';\n        messageDiv.dataset.key = key;\n\n        let displayContent;\n        if (parsed.callsign) {\n            displayContent = `<span class=\"callsign\">[${parsed.callsign}${parsed.location ? '/' + parsed.location : ''}]</span> ${this.escapeHtml(parsed.content)}`;\n        } else {\n            displayContent = this.escapeHtml(parsed.content);\n        }\n\n        // Show exact TTL for retrieved messages\n        const ttlDisplay = isRetrieved ? this.formatTTL(remainingTTL, true) : this.formatTTL(remainingTTL);\n        \n        const nodeInfo = nodeId ? `<span class=\"node-indicator\" title=\"Stored on ${nodeId}\">[${nodeId}]</span>` : '';\n        \n        const messageHTML = `\n            <div class=\"message-content\">${displayContent}</div>\n            <div class=\"message-meta\">\n                <span class=\"message-key\" onclick=\"fadeClient.copyToClipboard('${key}', event)\" title=\"Click to copy key\">KEY: ${key}</span>\n                ${nodeInfo}\n                <span class=\"ttl-indicator\" data-key=\"${key}\" title=\"Exact TTL: ${this.formatTTL(remainingTTL, true)}\">TTL: ${ttlDisplay}</span>\n            </div>\n        `;\n\n        messageDiv.innerHTML = messageHTML;\n\n        // Add expiring class if less than 5 minutes\n        if (remainingTTL < 300) {\n            messageDiv.classList.add('expiring');\n        }\n\n        const board = document.getElementById('messageBoard');\n        \n        // Remove loading message if present\n        const loading = board.querySelector('.loading');\n        if (loading) {\n            loading.remove();\n        }\n        \n        // Remove welcome message if present\n        const welcome = board.querySelector('.welcome-message');\n        if (welcome) {\n            welcome.remove();\n        }\n\n        // Insert at bottom (oldest first, like a chat)\n        board.appendChild(messageDiv);\n        \n        // Auto-scroll to bottom to show new message\n        board.scrollTop = board.scrollHeight;\n\n        // Store element reference\n        messageData.element = messageDiv;\n\n        // Limit board size to 100 messages\n        while (board.children.length > 100) {\n            const lastChild = board.lastChild;\n            const lastKey = lastChild.dataset.key;\n            if (lastKey) {\n                this.messages.delete(lastKey);\n            }\n            board.removeChild(lastChild);\n        }\n\n        // Update message count\n        document.getElementById('messageCount').textContent = this.messages.size;\n    }\n\n    removeMessage(key) {\n        const messageData = this.messages.get(key);\n        if (messageData && messageData.element) {\n            // Track expired message\n            this.expiredToday++;\n            this.saveExpiredCount();\n            \n            // Add expiring animation class\n            messageData.element.classList.add('expiring-now');\n            \n            // Play a glitch sound effect (optional - could be added later)\n            // this.playGlitchSound();\n            \n            // Remove after animation completes (2 seconds)\n            setTimeout(() => {\n                if (messageData.element.parentNode) {\n                    messageData.element.parentNode.removeChild(messageData.element);\n                }\n                this.messages.delete(key);\n                document.getElementById('messageCount').textContent = this.messages.size;\n            }, 2000);\n        } else {\n            this.messages.delete(key);\n            document.getElementById('messageCount').textContent = this.messages.size;\n        }\n        document.getElementById('expiredCount').textContent = this.expiredToday.toLocaleString();\n    }\n\n    startPolling() {\n        // Poll for new messages every 5 seconds (reduced frequency)\n        let scanCounter = 0;\n        this.pollInterval = setInterval(async () => {\n            // Skip some polls if there are no messages to reduce load\n            if (scanCounter % 2 === 0 && this.messages.size === 0) {\n                scanCounter++;\n                return;\n            }\n            \n            // Rotate through different scanning messages for visual feedback\n            const scanMessages = ['SCANNING NETWORK...', 'CHECKING NODES...', 'POLLING MESSAGES...'];\n            const scanMsg = scanMessages[scanCounter % scanMessages.length];\n            scanCounter++;\n            \n            this.updateConnectionStatus('scanning');\n            document.getElementById('statusText').textContent = scanMsg;\n            \n            try {\n                // Check if node is still healthy\n                const headers = {};\n                if (this.preferredNode) {\n                    headers['X-Preferred-Node'] = this.preferredNode;\n                }\n                \n                const healthEndpoint = this.connectionMode === 'direct' ? \n                    `${this.baseURL}/health` : \n                    `${this.baseURL}/api/health`;\n                const healthResponse = await fetch(healthEndpoint, { \n                    method: 'GET', \n                    headers: headers,\n                    timeout: 2000 \n                });\n                \n                if (!healthResponse.ok) {\n                    this.connected = false;\n                    this.updateConnectionStatus('error');\n                    document.getElementById('messageBoard').innerHTML = '<div class=\"loading\" style=\"color: #dc3545;\">Connection lost. Retrying...</div>';\n                    return;\n                }\n                \n                this.connected = true;\n                await this.loadRecentMessages();\n                // Update network status less frequently  \n                if (scanCounter % 3 === 0) {\n                    await this.updateNetworkStatus();\n                }\n                this.updateConnectionStatus('connected');\n            } catch (error) {\n                console.error('Polling error:', error);\n                this.connected = false;\n                this.updateConnectionStatus('error');\n                document.getElementById('messageBoard').innerHTML = '<div class=\"loading\" style=\"color: #dc3545;\">Connection lost. Retrying...</div>';\n            }\n        }, 5000); // Increased from 3 to 5 seconds\n    }\n\n    updateConnectionStatus(status, nodeId = null) {\n        const icon = document.getElementById('statusIcon');\n        const text = document.getElementById('statusText');\n        const info = document.getElementById('nodeInfo');\n        \n        switch(status) {\n            case 'scanning':\n                icon.className = 'status-icon scanning';\n                icon.textContent = '◈';\n                text.textContent = 'SCANNING NETWORK...';\n                break;\n            case 'connected':\n                icon.className = 'status-icon connected';\n                icon.textContent = '◆';\n                if (window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {\n                    text.textContent = 'PROXY MODE';\n                } else {\n                    text.textContent = 'CONNECTED';\n                }\n                if (this.preferredNode) {\n                    // Show preferred node\n                    info.textContent = `[Prefer: ${this.preferredNode}]`;\n                } else if (this.lastUsedNode) {\n                    info.textContent = `[Last: ${this.lastUsedNode.id}]`;\n                }\n                break;\n            case 'error':\n                icon.className = 'status-icon error';\n                icon.textContent = '◇';\n                text.textContent = 'CONNECTION ERROR';\n                info.textContent = '';\n                break;\n            default:\n                icon.className = 'status-icon';\n                icon.textContent = '◆';\n                text.textContent = 'INITIALIZING...';\n                info.textContent = '';\n        }\n    }\n\n    async switchNode(nodeUrl) {\n        if (nodeUrl) {\n            // Extract port number for preference\n            const port = nodeUrl.split(':').pop();\n            this.preferredNode = port;\n            console.log(`Setting preferred node to port ${port}`);\n            \n            // Update status immediately\n            document.getElementById('nodeInfo').textContent = `[Prefer: ${port}]`;\n        } else {\n            // Back to auto/round-robin\n            this.preferredNode = null;\n            console.log('Switching to auto/round-robin mode');\n            document.getElementById('nodeInfo').textContent = '';\n        }\n        \n        // Clear current messages and reload\n        this.messages.clear();\n        document.getElementById('messageBoard').innerHTML = '<div class=\"loading\">Updating node preference...</div>';\n        \n        // Reload messages\n        await this.loadRecentMessages();\n        this.updateConnectionStatus('connected');\n    }\n\n    startTTLUpdater() {\n        let updateCounter = 0;\n        this.ttlInterval = setInterval(() => {\n            updateCounter++;\n            \n            this.messages.forEach((data, key) => {\n                data.remainingTTL -= 1;\n\n                if (data.remainingTTL <= 0) {\n                    this.removeMessage(key);\n                } else {\n                    // Only update DOM every 5 seconds for non-critical TTLs to reduce thrashing\n                    const shouldUpdateDOM = data.remainingTTL < 300 || updateCounter % 5 === 0;\n                    \n                    if (shouldUpdateDOM) {\n                        const ttlSpan = data.element?.querySelector('.ttl-indicator');\n                        if (ttlSpan) {\n                            // Update display - show exact time for retrieved messages or under 1 hour\n                            const displayTTL = data.isRetrieved ? this.formatTTL(data.remainingTTL, true) : this.formatTTL(data.remainingTTL);\n                            ttlSpan.textContent = `TTL: ${displayTTL}`;\n                            \n                            // Always update the tooltip with exact time\n                            ttlSpan.title = `Exact TTL: ${this.formatTTL(data.remainingTTL, true)}`;\n                        }\n                    }\n\n                    // Add expiring class when < 5 minutes\n                    if (data.remainingTTL < 300 && data.element) {\n                        data.element.classList.add('expiring');\n                    }\n                }\n            });\n        }, 1000);\n    }\n\n    formatTTL(seconds, exact = false) {\n        if (exact || seconds < 3600) {\n            // Show exact time for messages under 1 hour or when exact is requested\n            const hours = Math.floor(seconds / 3600);\n            const minutes = Math.floor((seconds % 3600) / 60);\n            const secs = seconds % 60;\n            \n            if (hours > 0) {\n                return `${hours}h ${minutes}m ${secs}s`;\n            } else if (minutes > 0) {\n                return `${minutes}m ${secs}s`;\n            } else {\n                return `${secs}s`;\n            }\n        }\n        \n        // Approximate time for display\n        if (seconds < 60) return `${seconds}s`;\n        if (seconds < 3600) return `${Math.floor(seconds / 60)}m`;\n        if (seconds < 86400) {\n            const hours = Math.floor(seconds / 3600);\n            const minutes = Math.floor((seconds % 3600) / 60);\n            return minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;\n        }\n        const days = Math.floor(seconds / 86400);\n        const hours = Math.floor((seconds % 86400) / 3600);\n        return hours > 0 ? `${days}d ${hours}h` : `${days}d`;\n    }\n\n    async updateNetworkStatus() {\n        try {\n            // Update node status from the server\n            await this.updateNodeStatus();\n            \n            const activeNodes = this.nodes.filter(n => n.healthy).length;\n            \n            // Update node count\n            document.getElementById('nodeCount').textContent = activeNodes.toString();\n            \n            // Update expired count with real data\n            document.getElementById('expiredCount').textContent = this.expiredToday.toLocaleString();\n            \n            // Update message count\n            document.getElementById('messageCount').textContent = this.messages.size;\n            \n            // Update node health display\n            this.updateNodeHealth();\n        } catch (error) {\n            document.getElementById('nodeCount').textContent = '0';\n        }\n    }\n\n    updateNodeHealth() {\n        const nodeList = document.getElementById('nodeList');\n        nodeList.innerHTML = '';\n        \n        // Display all nodes from the server status\n        if (this.nodes.length > 0) {\n            this.nodes.forEach(node => {\n                const nodeItem = document.createElement('div');\n                nodeItem.className = 'node-item';\n                const port = node.url.split(':').pop();\n                nodeItem.innerHTML = `\n                    <span class=\"node-status ${node.healthy ? 'online' : 'offline'}\"></span>\n                    <span>${node.id}: localhost:${port} ${node.current ? '(current)' : ''}</span>\n                `;\n                nodeList.appendChild(nodeItem);\n            });\n        } else {\n            // Fallback to default display\n            const nodeItem = document.createElement('div');\n            nodeItem.className = 'node-item';\n            nodeItem.innerHTML = `\n                <span class=\"node-status ${this.connected ? 'online' : 'offline'}\"></span>\n                <span>Local Node: localhost:8080</span>\n            `;\n            nodeList.appendChild(nodeItem);\n        }\n    }\n\n    escapeHtml(text) {\n        const div = document.createElement('div');\n        div.textContent = text;\n        return div.innerHTML;\n    }\n\n    showError(message) {\n        const board = document.getElementById('messageBoard');\n        board.innerHTML = `<div class=\"loading\" style=\"color: #dc3545;\">${message}</div>`;\n    }\n    \n    copyToClipboard(text, event) {\n        // Get the element from the passed event\n        const element = event ? event.target : document.activeElement;\n        \n        // Check if we have clipboard API access\n        if (navigator.clipboard && window.isSecureContext) {\n            navigator.clipboard.writeText(text).then(() => {\n                // Add copied class for CSS animation\n                element.classList.add('copied');\n                \n                // Remove the class after animation completes\n                setTimeout(() => {\n                    element.classList.remove('copied');\n                }, 1500);\n            }).catch((err) => {\n                console.error('Clipboard API failed:', err);\n                this.fallbackCopy(text, element);\n            });\n        } else {\n            // Fallback for non-secure contexts\n            this.fallbackCopy(text, element);\n        }\n    }\n    \n    fallbackCopy(text, element) {\n        // Create a temporary textarea\n        const textarea = document.createElement('textarea');\n        textarea.value = text;\n        textarea.style.position = 'fixed';\n        textarea.style.left = '-999999px';\n        document.body.appendChild(textarea);\n        textarea.select();\n        \n        try {\n            document.execCommand('copy');\n            element.classList.add('copied');\n            setTimeout(() => {\n                element.classList.remove('copied');\n            }, 1500);\n        } catch (err) {\n            alert('Copy failed. Please manually copy: ' + text);\n        } finally {\n            document.body.removeChild(textarea);\n        }\n    }\n\n    destroy() {\n        if (this.pollInterval) {\n            clearInterval(this.pollInterval);\n        }\n        if (this.ttlInterval) {\n            clearInterval(this.ttlInterval);\n        }\n    }\n}\n\n// Initialize client\nlet fadeClient = null;\n\ndocument.addEventListener('DOMContentLoaded', async () => {\n    fadeClient = new RepramFadeClient();\n    await fadeClient.init();\n    \n    // Set up event listeners\n    const messageInput = document.getElementById('messageInput');\n    const charCount = document.getElementById('charCount');\n    const callsignInput = document.getElementById('callsignInput');\n    const locationInput = document.getElementById('locationInput');\n    const keyPreview = document.getElementById('keyPreview');\n    \n    // Load saved callsign and location\n    callsignInput.value = fadeClient.callsign;\n    locationInput.value = fadeClient.location;\n    \n    // Update key preview\n    function updateKeyPreview() {\n        const preview = fadeClient.generatePreviewKey();\n        keyPreview.textContent = preview;\n    }\n    updateKeyPreview();\n    \n    messageInput.addEventListener('input', function() {\n        charCount.textContent = this.value.length;\n        \n        // Warn when approaching limit\n        if (this.value.length > 250) {\n            charCount.style.color = '#ff0000';\n        } else {\n            charCount.style.color = '';\n        }\n        \n        updateKeyPreview();\n    });\n    \n    // Save callsign/location when changed\n    callsignInput.addEventListener('change', function() {\n        fadeClient.saveCallsign(this.value.toUpperCase(), locationInput.value.toUpperCase());\n    });\n    \n    locationInput.addEventListener('change', function() {\n        fadeClient.saveCallsign(callsignInput.value.toUpperCase(), this.value.toUpperCase());\n    });\n    \n    // Enter to submit (with Shift+Enter for new lines)\n    messageInput.addEventListener('keydown', function(e) {\n        if (e.key === 'Enter' && !e.shiftKey) {\n            e.preventDefault();\n            submitMessage();\n        }\n    });\n});\n\nasync function submitMessage() {\n    const messageInput = document.getElementById('messageInput');\n    const ttlSelect = document.getElementById('ttlSelect');\n    const sendButton = document.getElementById('sendButton');\n    const callsignInput = document.getElementById('callsignInput');\n    const locationInput = document.getElementById('locationInput');\n    \n    const content = messageInput.value.trim();\n    const ttl = ttlSelect.value;\n    const callsign = callsignInput.value.trim().toUpperCase();\n    const location = locationInput.value.trim().toUpperCase();\n    \n    if (!content) {\n        alert('Please enter a message');\n        return;\n    }\n    \n    if (content.includes('|') || callsign.includes('|') || location.includes('|')) {\n        alert('Messages, callsigns, and locations cannot contain the | character');\n        return;\n    }\n    \n    // Disable button while sending\n    sendButton.disabled = true;\n    const originalText = sendButton.textContent;\n    sendButton.textContent = 'TRANSMITTING...';\n    \n    try {\n        const key = await fadeClient.submitMessage(content, ttl, callsign, location);\n        \n        // Clear input\n        messageInput.value = '';\n        document.getElementById('charCount').textContent = '0';\n        \n        // Generate new key for next message\n        fadeClient.nextKey = null;\n        const preview = fadeClient.generatePreviewKey();\n        document.getElementById('keyPreview').textContent = preview;\n        \n        // Show success\n        sendButton.textContent = 'TRANSMITTED!';\n        sendButton.style.background = '#00ff00';\n        sendButton.style.color = '#000';\n        \n        setTimeout(() => {\n            sendButton.textContent = originalText;\n            sendButton.style.background = '';\n            sendButton.style.color = '';\n            sendButton.disabled = false;\n        }, 2000);\n        \n    } catch (error) {\n        alert('Failed to send message. Please try again.');\n        sendButton.textContent = originalText;\n        sendButton.disabled = false;\n    }\n}\n\nasync function lookupMessage() {\n    const keyInput = document.getElementById('keyInput');\n    const key = keyInput.value.trim();\n    \n    if (!key) {\n        alert('Please enter a message key');\n        return;\n    }\n    \n    const resultDiv = document.getElementById('lookupResult');\n    resultDiv.innerHTML = '<div style=\"color: #888;\">Looking up message...</div>';\n    \n    try {\n        const message = await fadeClient.getMessage(key);\n        \n        if (message) {\n            const parsed = fadeClient.parseMessage(message.content);\n            let displayContent;\n            \n            if (parsed.callsign) {\n                displayContent = `<strong>[${parsed.callsign}${parsed.location ? '/' + parsed.location : ''}]</strong> ${fadeClient.escapeHtml(parsed.content)}`;\n            } else {\n                displayContent = fadeClient.escapeHtml(parsed.content);\n            }\n            \n            const nodeInfo = message.nodeId ? ` <span style=\"color: #ff00ff; font-size: 0.8em;\">[from ${message.nodeId}]</span>` : '';\n            \n            resultDiv.innerHTML = `\n                <div class=\"lookup-success\">\n                    <div style=\"margin-bottom: 8px;\"><strong>Message found:</strong></div>\n                    <div style=\"font-style: italic; margin-bottom: 8px;\">${displayContent}</div>\n                    <div style=\"font-size: 0.9em; color: #00ffff;\">\n                        <strong>TTL Remaining:</strong> ${fadeClient.formatTTL(message.remaining_ttl, true)}${nodeInfo}\n                    </div>\n                </div>\n            `;\n            \n            // Also display the message in the main board with exact TTL\n            fadeClient.displayMessage(key, message.content, message.remaining_ttl, message.nodeId, true);\n        } else {\n            resultDiv.innerHTML = `\n                <div class=\"lookup-error\">\n                    <strong>Message not found</strong><br>\n                    <span style=\"font-size: 0.9em;\">The message may have expired or the key might be incorrect.</span>\n                </div>\n            `;\n        }\n    } catch (error) {\n        resultDiv.innerHTML = `\n            <div class=\"lookup-error\">\n                <strong>Error looking up message</strong><br>\n                <span style=\"font-size: 0.9em;\">Please check the key and try again.</span>\n            </div>\n        `;\n    }\n}\n\n\n// Clean up on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (fadeClient) {\n        fadeClient.destroy();\n    }\n});"
          },
          "redirectURL": "",
          "headersSize": 0,
          "bodySize": 39258
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "ssl": 0,
          "connect": 0,
          "send": 0,
          "wait": 0,
          "receive": 0
        },
        "time": 0,
        "_securityState": "insecure",
        "pageref": "page_1"
      },
      {
        "startedDateTime": "2025-06-11T08:55:09.424-04:00",
        "request": {
          "bodySize": 0,
          "method": "GET",
          "url": "http://localhost:8081/api/health",
          "httpVersion": "",
          "headers": [
            {
              "name": "Host",
              "value": "localhost:8081"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:139.0) Gecko/20100101 Firefox/139.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Referer",
              "value": "http://192.168.68.60:3000/"
            },
            {
              "name": "Origin",
              "value": "http://192.168.68.60:3000"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "empty"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "cross-site"
            },
            {
              "name": "Priority",
              "value": "u=4"
            }
          ],
          "cookies": [],
          "queryString": [],
          "headersSize": 416
        },
        "response": {
          "status": 0,
          "statusText": "",
          "httpVersion": "",
          "headers": [],
          "cookies": [],
          "content": {},
          "redirectURL": "",
          "headersSize": 0,
          "bodySize": -1
        },
        "cache": {},
        "timings": {},
        "time": 0,
        "pageref": "page_1"
      },
      {
        "startedDateTime": "2025-06-11T08:55:09.424-04:00",
        "request": {
          "bodySize": 0,
          "method": "GET",
          "url": "http://192.168.68.60:3000/favicon.ico",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Host",
              "value": "192.168.68.60:3000"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:139.0) Gecko/20100101 Firefox/139.0"
            },
            {
              "name": "Accept",
              "value": "image/avif,image/webp,image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Referer",
              "value": "http://192.168.68.60:3000/fade/"
            },
            {
              "name": "Cookie",
              "value": "CookieConsent=false; cookieConsent=false"
            }
          ],
          "cookies": [
            {
              "name": "CookieConsent",
              "value": "false"
            },
            {
              "name": "cookieConsent",
              "value": "false"
            }
          ],
          "queryString": [],
          "headersSize": 0
        },
        "response": {
          "status": 404,
          "statusText": "Not Found",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "accept-ranges",
              "value": "bytes"
            },
            {
              "name": "Date",
              "value": "Wed, 11 Jun 2025 12:52:22 GMT"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Content-Length",
              "value": "0"
            }
          ],
          "cookies": [],
          "content": {
            "mimeType": "image/x-icon",
            "size": 0,
            "encoding": "base64",
            "text": ""
          },
          "redirectURL": "",
          "headersSize": 0,
          "bodySize": 0
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "ssl": 0,
          "connect": 0,
          "send": 0,
          "wait": 0,
          "receive": 0
        },
        "time": 0,
        "_securityState": "insecure",
        "pageref": "page_1"
      }
    ]
  }
}